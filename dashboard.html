<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>JIRA Dashboard</title>
    <link href="https://fonts.googleapis.com/css2?family=Inter:wght@300;400;500;600;700&display=swap" rel="stylesheet">
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.5.0/css/all.min.css">
    <style>
        * { margin: 0; padding: 0; box-sizing: border-box; }
        body {
            font-family: 'Inter', sans-serif;
            background: linear-gradient(135deg, #0f1419 0%, #1a2332 50%, #2c5282 100%);
            min-height: 100vh; color: #333; padding: 20px;
        }
        .container { max-width: 1400px; margin: 0 auto; }
        .header {
            background: rgba(255, 255, 255, 0.95); backdrop-filter: blur(10px);
            padding: 30px; border-radius: 20px; margin-bottom: 30px;
            box-shadow: 0 10px 40px rgba(0, 0, 0, 0.15); text-align: center;
        }
        .header h1 { font-size: 2.5rem; font-weight: 700; color: #1a202c; margin-bottom: 10px; }
        .header p { font-size: 1.1rem; color: #4a5568; font-weight: 400; }
        .search-section {
            background: rgba(255, 255, 255, 0.9); backdrop-filter: blur(10px);
            padding: 40px; border-radius: 20px; margin-bottom: 30px;
            box-shadow: 0 8px 32px rgba(0, 0, 0, 0.1);
        }
        .search-section h2 { font-size: 1.5rem; font-weight: 600; color: #2d3748; margin-bottom: 20px; }
        .search-controls { display: flex; gap: 15px; align-items: center; flex-wrap: wrap; }
        .search-input {
            flex: 1; min-width: 800px; width: 100%; padding: 15px 20px; border: 2px solid #e2e8f0;
            border-radius: 12px; font-size: 16px; font-family: inherit; transition: all 0.3s ease;
        }
        .search-input:focus { outline: none; border-color: #3182ce; box-shadow: 0 0 0 3px rgba(49, 130, 206, 0.1); }
        
        .search-container {
            position: relative;
            flex: 1;
            min-width: 800px;
        }
        
        .suggestions-dropdown {
            position: absolute;
            top: 100%;
            left: 0;
            right: 0;
            background: white;
            border: 2px solid #e2e8f0;
            border-top: none;
            border-radius: 0 0 12px 12px;
            max-height: 200px;
            overflow-y: auto;
            z-index: 1000;
            display: none;
            box-shadow: 0 4px 12px rgba(0, 0, 0, 0.15);
        }
        
        .suggestion-item {
            padding: 10px 15px;
            cursor: pointer;
            border-bottom: 1px solid #f1f5f9;
            transition: background-color 0.2s ease;
        }
        
        .suggestion-item:hover, .suggestion-item.highlighted {
            background-color: #f8fafc;
        }
        
        .suggestion-item:last-child {
            border-bottom: none;
        }
        
        .suggestion-main {
            font-weight: 600;
            color: #2d3748;
        }
        
        .suggestion-desc {
            font-size: 0.85rem;
            color: #718096;
            margin-top: 2px;
        }
        .btn {
            padding: 15px 30px; border: none; border-radius: 12px; font-size: 16px;
            font-weight: 600; cursor: pointer; transition: all 0.3s ease;
            display: inline-flex; align-items: center; gap: 8px; text-decoration: none;
        }
        .btn-primary { background: linear-gradient(135deg, #3182ce, #2c5aa0); color: white; }
        .btn-primary:hover { transform: translateY(-2px); box-shadow: 0 8px 25px rgba(49, 130, 206, 0.4); }
        .btn-secondary { background: linear-gradient(135deg, #718096, #4a5568); color: white; }
        .btn-secondary:hover { transform: translateY(-2px); box-shadow: 0 8px 25px rgba(113, 128, 150, 0.4); }
        .loading { text-align: center; color: white; padding: 60px 20px; display: none; }
        .loading h3 { font-size: 1.5rem; margin-bottom: 10px; }
        .loading .spinner {
            width: 40px; height: 40px; border: 4px solid rgba(255, 255, 255, 0.3);
            border-top: 4px solid white; border-radius: 50%; animation: spin 1s linear infinite; margin: 20px auto;
        }
        @keyframes spin { 0% { transform: rotate(0deg); } 100% { transform: rotate(360deg); } }
        .empty-state { text-align: center; color: white; padding: 60px 20px; }
        .empty-state h3 { font-size: 1.8rem; margin-bottom: 15px; font-weight: 600; }
        .empty-state p { font-size: 1.1rem; opacity: 0.9; max-width: 600px; margin: 0 auto; line-height: 1.6; }
        .results { margin-top: 30px; display: none; }
        .feature-card {
            background: rgba(255, 255, 255, 0.95); backdrop-filter: blur(10px);
            border-radius: 20px; margin: 20px 0; box-shadow: 0 8px 32px rgba(0, 0, 0, 0.1);
            transition: all 0.3s ease; overflow: hidden;
        }
        .feature-card:hover { transform: translateY(-5px); box-shadow: 0 20px 60px rgba(0, 0, 0, 0.15); }
        .feature-header {
            padding: 25px 30px; cursor: pointer; font-weight: 600; color: #2d3748;
            display: flex; align-items: center; justify-content: space-between;
            background: linear-gradient(135deg, #f7fafc 0%, #edf2f7 100%);
        }
        .feature-header:hover { background: linear-gradient(135deg, #edf2f7 0%, #e2e8f0 100%); }
        .feature-header i { font-size: 1.2rem; color: #3182ce; margin-right: 12px; }
        .feature-title { display: flex; align-items: center; flex: 1; }
        .feature-toggle-icon { transition: transform 0.3s ease; }
        .feature-card.expanded .feature-toggle-icon { transform: rotate(45deg); }
        .feature-details { display: none; padding: 30px; background: white; }
        .section-toggle-icon { 
            transition: transform 0.3s ease, color 0.3s ease; 
            cursor: pointer;
        }
        .section-expanded .section-toggle-icon { 
            transform: rotate(45deg); 
            color: #dc2626 !important;
        }
        .section-toggle-icon:hover {
            transform: scale(1.1);
        }
        
        .feature-branch-structure { font-family: 'Inter', sans-serif; }
        .branch-item { margin-bottom: 10px; }
        .branch-item strong { color: #1f2937; font-size: 14px; }
        .sub-details { margin-left: 20px; margin-top: 8px; }
        .story-branch-item, .bug-branch-item { 
            padding: 8px 0; 
            border-bottom: 1px solid #f3f4f6; 
            font-size: 13px; 
            line-height: 1.4;
        }
        .story-branch-item:last-child, .bug-branch-item:last-child { border-bottom: none; }
        .story-grid {
            display: grid; grid-template-columns: repeat(auto-fit, minmax(350px, 1fr));
            gap: 20px; margin-top: 20px;
        }
        
        .story-list {
            margin-top: 15px;
        }
        
        .story-list-item {
            position: relative;
        }
        
        .story-list-item .story-details {
            position: static !important;
            margin-top: 12px !important;
            border-radius: 6px !important;
            border: 1px solid #e2e8f0 !important;
            background: #f8fafc !important;
            box-shadow: inset 0 2px 4px 0 rgba(0, 0, 0, 0.06) !important;
            z-index: auto !important;
        }
        
                .story-card {
            background: #e6f3ff; border: 1px solid #4a90e2; border-radius: 8px; padding: 12px; margin: 8px 0;
            transition: all 0.3s ease;
        }
        .story-card:hover { border-color: #3182ce; box-shadow: 0 8px 25px rgba(49, 130, 206, 0.1); }
        
        .story-details {
            background: #f7fafc; 
            border-top: 1px solid #e2e8f0; 
            margin-top: 12px; 
            padding: 12px; 
            border-radius: 6px;
            display: none;
        }
        
        .story-expand-btn {
            background: #4299e1; 
            color: white; 
            border: none; 
            border-radius: 4px; 
            padding: 4px 8px; 
            margin-left: 8px; 
            cursor: pointer; 
            font-size: 12px;
            transition: all 0.2s ease;
        }
        
        .story-expand-btn:hover { 
            background: #3182ce; 
            transform: scale(1.05); 
        }
        .story-key {
            background: linear-gradient(135deg, #3182ce, #2c5aa0); color: white;
            padding: 6px 14px; border-radius: 20px; font-size: 13px; font-weight: 600;
            display: inline-block; margin-bottom: 12px;
        }
        .story-title { font-size: 1rem; font-weight: 600; color: #2d3748; margin-bottom: 10px; line-height: 1.4; }
        .story-status { font-size: 0.9rem; color: #4a5568; margin-bottom: 8px; }
        .story-sprint { font-size: 0.9rem; color: #1e3a8a; margin-bottom: 8px; }
        .story-assignee { font-size: 0.9rem; color: #718096; }
        .bugs-section { margin-top: 15px; padding-top: 15px; border-top: 1px solid #e2e8f0; }
        .bugs-title {
            font-size: 0.9rem; font-weight: 600; color: #e53e3e; margin-bottom: 8px;
            display: flex; align-items: center; gap: 6px;
        }
        .bug-item {
            background: linear-gradient(135deg, #fed7d7, #feb2b2); color: #c53030;
            padding: 6px 12px; border-radius: 12px; font-size: 12px; font-weight: 500;
            margin: 4px 6px 4px 0; display: inline-block; border: 1px solid #fc8181;
        }
        .bug-card { transition: all 0.2s ease; }
        .bug-card:hover { transform: translateY(-1px); box-shadow: 0 4px 12px rgba(237, 137, 54, 0.15); }
        .error {
            background: linear-gradient(135deg, #fed7d7, #feb2b2); color: #742a2a;
            padding: 30px; border-radius: 15px; text-align: center; margin: 20px 0; border: 1px solid #fc8181;
        }
        .error h3 { margin-bottom: 10px; font-weight: 600; }
        .stats-summary {
            display: grid; grid-template-columns: repeat(auto-fit, minmax(200px, 1fr));
            gap: 20px; margin-bottom: 20px; padding: 20px;
            background: rgba(255, 255, 255, 0.1); border-radius: 15px;
        }
        .stat-item { text-align: center; color: white; }
        .stat-number { font-size: 2rem; font-weight: 700; margin-bottom: 5px; }
        .stat-label { font-size: 0.9rem; opacity: 0.9; font-weight: 500; }
        .email-button {
            margin-left: 15px; padding: 8px 16px; background: linear-gradient(135deg, #667eea 0%, #764ba2 100%); 
            color: white; border: none; border-radius: 6px; cursor: pointer; font-size: 14px; 
            font-weight: 500; display: flex; align-items: center; gap: 6px; transition: all 0.3s ease;
            box-shadow: 0 2px 8px rgba(102, 126, 234, 0.3);
        }
        .email-button:hover {
            background: linear-gradient(135deg, #5a67d8 0%, #6b46c1 100%);
            transform: translateY(-1px);
            box-shadow: 0 4px 12px rgba(102, 126, 234, 0.4);
        }
        @media (max-width: 768px) {
            .search-controls { flex-direction: column; align-items: stretch; }
            .search-input { min-width: unset; width: 100%; }
            .search-container { min-width: unset; }
            .story-grid { grid-template-columns: 1fr; }
            .header h1 { font-size: 2rem; }
            .stats-summary { grid-template-columns: repeat(2, 1fr); }
        }
        @media (max-width: 480px) {
            body { padding: 10px; }
            .header, .search-section, .feature-header { padding: 20px; }
            .feature-details { padding: 20px; }
            .stats-summary { grid-template-columns: 1fr; gap: 10px; }
        }
    </style>
</head>
<body>
    <div class="container">
        <div class="header">
            <h1><i class="fas fa-tasks"></i> JIRA Dashboard</h1>
            <p>Epic & Story Management System with Advanced Bug Detection</p>
        </div>
        <div class="search-section">
            <h2><i class="fas fa-search"></i> Search JIRA Epics & Stories</h2>
            <div class="search-controls">
                <div class="search-container">
                    <input type="text" id="jqlInput" class="search-input" value="project = CTL-Fix AND fixVersion =&quot;CT PI26 Sep17-Jan06&quot; AND issuetype = &quot;Epic (Feature)&quot; AND &quot;Team[Team]&quot; = 5441" placeholder="Enter JQL query">
                    <div id="suggestionsDropdown" class="suggestions-dropdown"></div>
                </div>
                <button class="btn btn-primary" onclick="console.log('Search button clicked'); searchJira();"><i class="fas fa-search"></i> Search</button>
                <button class="btn btn-secondary" onclick="clearResults()"><i class="fas fa-times"></i> Clear</button>
            </div>
        </div>
        <div id="loadingState" class="loading">
            <div class="spinner"></div>
            <h3>Searching JIRA...</h3>
            <p>Please wait while we fetch your data</p>
        </div>
        <div id="searchResults" class="results"><div id="resultsContent"></div></div>
        <div id="emptyState" class="empty-state">
            <h3><i class="fas fa-rocket"></i> Ready to Search</h3>
            <p>Enter a JQL query above to start exploring your JIRA epics and stories. The dashboard will automatically detect and highlight any blocking bugs.</p>
        </div>
    </div>

    <script>
        let searchData = [];
        const SPRINT_FIELD_FALLBACK = 'customfield_10020';
        let sprintFieldId = SPRINT_FIELD_FALLBACK;
        let sprintFieldReady = initializeSprintFieldId();
        const sprintFieldCache = new Map();
        let currentSearchController = null;
        let currentSearchStream = null;
        let currentSearchAccumulator = [];
        let currentSearchRequestId = null;
        let currentSearchMeta = null;
        let lastExecutedJql = '';
        let searchCancelled = false;
        const loadingStateElement = document.getElementById('loadingState');
        const defaultLoadingHtml = loadingStateElement ? loadingStateElement.innerHTML : '';

        function resetLoadingState() {
            if (loadingStateElement) {
                loadingStateElement.innerHTML = defaultLoadingHtml;
            }
        }

        function cancelOngoingSearch(reason = 'Search cancelled by user action') {
            if (currentSearchController) {
                try {
                    currentSearchController.abort();
                } catch (error) {
                    console.warn('Abort controller error during cancel:', error);
                }
                currentSearchController = null;
            }
            if (currentSearchStream) {
                try {
                    currentSearchStream.close();
                } catch (error) {
                    console.warn('Stream close error during cancel:', error);
                }
                currentSearchStream = null;
            }
            currentSearchAccumulator = [];
            currentSearchRequestId = null;
            currentSearchMeta = null;
            window.currentSearchMeta = null;
            if (!searchCancelled) {
                console.log(reason);
            }
            searchCancelled = true;
            showLoading(false);
        }

        function prepareNewSearchController() {
            if (currentSearchController) {
                try {
                    currentSearchController.abort();
                } catch (error) {
                    console.warn('Abort controller error while preparing new search:', error);
                }
            }
            if (currentSearchStream) {
                try {
                    currentSearchStream.close();
                } catch (error) {
                    console.warn('Stream close error while preparing new search:', error);
                }
                currentSearchStream = null;
            }
            searchCancelled = false;
            currentSearchController = new AbortController();
            currentSearchAccumulator = [];
            currentSearchRequestId = null;
            return currentSearchController;
        }

        function hasSearchBeenCancelled() {
            return searchCancelled || (currentSearchController && currentSearchController.signal.aborted);
        }

        async function initializeSprintFieldId() {
            try {
                console.log('Resolving sprint field id from metadata');
                const response = await fetch('http://localhost:3000/api/jira/field-metadata');
                if (!response.ok) {
                    throw new Error(`Metadata request failed with status ${response.status}`);
                }

                const fields = await response.json();
                if (Array.isArray(fields)) {
                    const sprintField = fields.find(field => field.name === 'Sprint');
                    if (sprintField && sprintField.id) {
                        sprintFieldId = sprintField.id;
                        console.log('Sprint field resolved to:', sprintFieldId);
                        return sprintFieldId;
                    }
                }

                sprintFieldId = SPRINT_FIELD_FALLBACK;
                console.warn('Sprint field not resolved from metadata; using fallback:', sprintFieldId);
                return sprintFieldId;
            } catch (error) {
                sprintFieldId = SPRINT_FIELD_FALLBACK;
                console.warn('Failed to resolve sprint field id; using fallback:', sprintFieldId, error);
                return sprintFieldId;
            }
        }

        // Function to open JIRA issue in new tab
        function openJiraIssue(issueKey) {
            // Replace with your actual JIRA base URL
            const jiraBaseUrl = 'https://lumen.atlassian.net';
            const jiraUrl = `${jiraBaseUrl}/browse/${issueKey}`;
            window.open(jiraUrl, '_blank');
        }

        async function searchJira() {
            console.log('searchJira function called');
            const jql = document.getElementById('jqlInput').value.trim();
            console.log('JQL input value:', jql);
            if (!jql) {
                alert('Please enter a JQL query');
                return;
            }

            lastExecutedJql = jql;
            currentSearchMeta = null;
            window.currentSearchMeta = null;

            const controller = prepareNewSearchController();
            const { signal } = controller;

            resetLoadingState();
            showLoading(true);
            hideResults();
            hideEmptyState();

            try {
                await sprintFieldReady;
                const includeFields = new Set([SPRINT_FIELD_FALLBACK]);
                if (sprintFieldId) {
                    includeFields.add(sprintFieldId);
                }

                const payload = {
                    jql,
                    maxResults: 100,
                    includeFields: Array.from(includeFields)
                };

                console.log('Starting async search with payload:', payload);
                const response = await fetch('http://localhost:3000/async/search', {
                    method: 'POST',
                    headers: {
                        'Content-Type': 'application/json'
                    },
                    body: JSON.stringify(payload),
                    signal
                });

                console.log('Async search response status:', response.status);
                const meta = await response.json();
                console.log('Async search response body:', meta);

                if (meta.error) {
                    throw new Error(meta.error);
                }

                if (response.status === 200 && meta?.data) {
                    console.log('Async search served from cache, processing immediately.');
                    await finalizeSearchData(meta.data, {
                        signal,
                        requestId: meta.requestId,
                        source: 'cache',
                        meta: meta.meta
                    });
                    if (!hasSearchBeenCancelled()) {
                        showLoading(false);
                    }
                    return;
                }

                if (response.status === 202 && meta?.requestId) {
                    console.log('Async search pending, attaching to stream.');
                    attachSearchStream(meta, { signal });
                    return;
                }

                throw new Error(`Unexpected async search response: ${response.status}`);
            } catch (error) {
                if (error.name === 'AbortError' || hasSearchBeenCancelled()) {
                    console.log('Search aborted:', error.message || error);
                } else {
                    console.error('Search error:', error);
                    showError(error.message);
                }
            } finally {
                if (!hasSearchBeenCancelled() && !currentSearchStream) {
                    showLoading(false);
                }
            }
        }

        function buildProxyUrl(pathOrUrl) {
            if (!pathOrUrl) {
                return null;
            }
            if (/^https?:/i.test(pathOrUrl)) {
                return pathOrUrl;
            }
            const normalized = pathOrUrl.startsWith('/') ? pathOrUrl : `/${pathOrUrl}`;
            return `http://localhost:3000${normalized}`;
        }

        function updateLoadingProgress(title, subtitle = 'Preparing Jira results...') {
            if (!loadingStateElement || loadingStateElement.style.display !== 'block') {
                return;
            }
            loadingStateElement.innerHTML = `
                <div class="spinner"></div>
                <h3>${title}</h3>
                <p>${subtitle}</p>
            `;
        }

        async function finalizeSearchData(rawData, context = {}) {
            if (hasSearchBeenCancelled()) {
                console.log('Skipping finalizeSearchData because search was cancelled.');
                return;
            }

            const { signal } = context;
            const normalizedData = rawData && typeof rawData === 'object' && !Array.isArray(rawData)
                ? rawData
                : { issues: Array.isArray(rawData) ? rawData : [] };
            const issueArray = Array.isArray(normalizedData.issues) ? normalizedData.issues : [];
            console.log(`Finalizing search with ${issueArray.length} issues`, {
                ...context,
                total: normalizedData.total,
                startAt: normalizedData.startAt,
                maxResults: normalizedData.maxResults
            });

            const enrichedIssues = await ensureEpicsPresent(issueArray, { signal });
            if (hasSearchBeenCancelled()) {
                console.log('Finalization aborted after enrichment due to cancellation.');
                return;
            }

            if (context.merge && Array.isArray(searchData) && searchData.length > 0) {
                searchData = mergeIssuesByKey(searchData, enrichedIssues);
            } else {
                searchData = enrichedIssues;
            }
            window.currentSearchData = searchData;
            window.currentEpicsWithStories = {};
            await processAndDisplayResults({ signal });

            const metaSource = context.meta || {};
            const totalIssues = Number.isFinite(metaSource.total)
                ? metaSource.total
                : (Number.isFinite(normalizedData.total) ? normalizedData.total : searchData.length);
            const startAt = Number.isFinite(metaSource.startAt)
                ? metaSource.startAt
                : (Number.isFinite(normalizedData.startAt) ? normalizedData.startAt : 0);
            const maxResults = Number.isFinite(metaSource.maxResults)
                ? metaSource.maxResults
                : (Number.isFinite(normalizedData.maxResults) ? normalizedData.maxResults : issueArray.length);
            const nextPageToken = typeof metaSource.nextPageToken === 'string' && metaSource.nextPageToken.length > 0
                ? metaSource.nextPageToken
                : (typeof normalizedData.nextPageToken === 'string' && normalizedData.nextPageToken.length > 0
                    ? normalizedData.nextPageToken
                    : null);
            const nextStartAt = nextPageToken
                ? searchData.length
                : (Number.isFinite(metaSource.nextStartAt)
                    ? metaSource.nextStartAt
                    : searchData.length);
            const aggregatedMeta = {
                total: totalIssues,
                startAt,
                maxResults,
                pageSize: issueArray.length,
                nextStartAt,
                nextPageToken,
                isLast: typeof metaSource.isLast === 'boolean'
                    ? metaSource.isLast
                    : (typeof normalizedData.isLast === 'boolean' ? normalizedData.isLast : undefined),
                hasMore: typeof metaSource.hasMore === 'boolean'
                    ? metaSource.hasMore
                    : (nextPageToken ? true : (typeof metaSource.isLast === 'boolean'
                        ? !metaSource.isLast
                        : (typeof normalizedData.isLast === 'boolean'
                            ? !normalizedData.isLast
                            : (Number.isFinite(totalIssues) && totalIssues > 0
                                ? nextStartAt < totalIssues
                                : false))))
            };
            currentSearchMeta = aggregatedMeta;
            window.currentSearchMeta = currentSearchMeta;

            currentSearchAccumulator = [];
            currentSearchRequestId = null;
        }

        function attachSearchStream(meta, options = {}) {
            if (hasSearchBeenCancelled()) {
                console.log('Skipping stream attachment because search was cancelled.');
                return;
            }

            const streamUrl = buildProxyUrl(meta?.streamUrl);
            if (!streamUrl || !meta?.requestId) {
                showError('Unable to attach to search stream.');
                showLoading(false);
                return;
            }

            currentSearchRequestId = meta.requestId;
            currentSearchAccumulator = [];

            updateLoadingProgress('Preparing Jira results...', 'Streaming data from server');

            try {
                currentSearchStream = new EventSource(streamUrl);
            } catch (error) {
                console.error('Failed to open EventSource:', error);
                fetchPollingSnapshot(meta, options);
                return;
            }

            const { signal } = options;

            currentSearchStream.onmessage = async (event) => {
                if (hasSearchBeenCancelled() || currentSearchRequestId !== meta.requestId) {
                    return;
                }

                try {
                    const payload = JSON.parse(event.data || '{}');
                    if (!payload?.type) {
                        return;
                    }

                    switch (payload.type) {
                        case 'status':
                            if (payload.message) {
                                updateLoadingProgress(payload.message, 'Streaming data from Jira');
                            }
                            break;
                        case 'issuesChunk':
                            if (Array.isArray(payload.chunk)) {
                                currentSearchAccumulator.push(...payload.chunk);
                                updateLoadingProgress(
                                    `Received ${currentSearchAccumulator.length} issues`,
                                    'Continuing to stream results...'
                                );
                            }
                            break;
                        case 'complete': {
                            console.log('Stream complete payload received.');
                            if (currentSearchStream) {
                                try {
                                    currentSearchStream.close();
                                } catch (closeError) {
                                    console.warn('Stream close error after completion:', closeError);
                                }
                                currentSearchStream = null;
                            }

                            const finalIssues = Array.isArray(payload?.data?.issues)
                                ? payload.data.issues
                                : currentSearchAccumulator;
                            const finalPayload = payload?.data && typeof payload.data === 'object'
                                ? payload.data
                                : { issues: finalIssues };
                            if (!Array.isArray(finalPayload.issues)) {
                                finalPayload.issues = finalIssues;
                            }

                            try {
                                await finalizeSearchData(finalPayload, {
                                    signal,
                                    requestId: meta.requestId,
                                    source: 'stream',
                                    meta: payload.meta,
                                    merge: options.merge === true
                                });
                                if (!hasSearchBeenCancelled()) {
                                    showLoading(false);
                                }
                            } catch (finalizeError) {
                                console.error('Failed to finalize streamed data:', finalizeError);
                                showError(finalizeError.message || 'Failed to finalize results');
                                showLoading(false);
                            }
                            break;
                        }
                        case 'error':
                            console.error('Stream reported error:', payload);
                            if (currentSearchStream) {
                                try {
                                    currentSearchStream.close();
                                } catch (closeError) {
                                    console.warn('Stream close error after error event:', closeError);
                                }
                                currentSearchStream = null;
                            }
                            showError(payload.message || 'Search failed in background');
                            showLoading(false);
                            break;
                        default:
                            console.log('Unhandled stream event type:', payload.type, payload);
                    }
                } catch (parseError) {
                    console.error('Failed to parse stream event:', parseError, event.data);
                }
            };

            currentSearchStream.onerror = (eventError) => {
                console.error('Stream connection error:', eventError);
                if (currentSearchStream) {
                    try {
                        currentSearchStream.close();
                    } catch (closeError) {
                        console.warn('Stream close error on connection failure:', closeError);
                    }
                    currentSearchStream = null;
                }

                if (!hasSearchBeenCancelled()) {
                    updateLoadingProgress('Switching to polling...', 'Stream interrupted, retrying via polling');
                    fetchPollingSnapshot(meta, { signal, merge: options.merge === true });
                }
            };
        }

        async function fetchPollingSnapshot(meta, options = {}) {
            if (hasSearchBeenCancelled()) {
                return;
            }

            const pollUrl = buildProxyUrl(meta?.pollUrl);
            if (!pollUrl || !meta?.requestId) {
                showError('Unable to poll for search progress.');
                showLoading(false);
                return;
            }

            try {
                const response = await fetch(pollUrl, options.signal ? { signal: options.signal } : {});
                const payload = await response.json();

                if (response.status >= 400) {
                    throw new Error(payload?.error?.message || payload?.error || `Polling failed with status ${response.status}`);
                }

                if (payload.status === 'complete' && payload.data) {
                    await finalizeSearchData(payload.data, {
                        signal: options.signal,
                        requestId: meta.requestId,
                        source: 'poll',
                        meta: payload.meta,
                        merge: options.merge === true
                    });
                    if (!hasSearchBeenCancelled()) {
                        showLoading(false);
                    }
                    return;
                }

                if (payload.status === 'error') {
                    showError(payload?.error?.message || 'Background search failed');
                    showLoading(false);
                    return;
                }

                if (currentSearchRequestId !== meta.requestId) {
                    return;
                }

                updateLoadingProgress(
                    `Collected ${payload.collectedCount || 0} issues`,
                    'Continuing background processing...'
                );

                if (hasSearchBeenCancelled()) {
                    return;
                }

                setTimeout(() => {
                    if (!hasSearchBeenCancelled() && currentSearchRequestId === meta.requestId) {
                        fetchPollingSnapshot(meta, options);
                    }
                }, 1000);
            } catch (error) {
                if (error.name === 'AbortError' || hasSearchBeenCancelled()) {
                    return;
                }
                console.error('Polling snapshot error:', error);
                showError(error.message || 'Unable to retrieve search progress');
                showLoading(false);
            }
        }

        async function requestNextSearchPage() {
            if (!currentSearchMeta || !currentSearchMeta.hasMore) {
                showDashboardToast('All available results are already loaded.', 'info');
                return;
            }

            if (!lastExecutedJql) {
                showDashboardToast('No previous search to extend.', 'warning');
                return;
            }

            const nextPageToken = typeof currentSearchMeta.nextPageToken === 'string' && currentSearchMeta.nextPageToken.length > 0
                ? currentSearchMeta.nextPageToken
                : null;
            const nextStartAt = Number.isFinite(currentSearchMeta.nextStartAt)
                ? currentSearchMeta.nextStartAt
                : (Array.isArray(searchData) ? searchData.length : 0);

            const paginationContainer = document.getElementById('asyncPaginationContainer');
            if (paginationContainer) {
                paginationContainer.innerHTML = '<div style="color: #4b5563; font-size: 13px;">Loading additional issues...</div>';
            }

            const controller = prepareNewSearchController();
            const { signal } = controller;

            showLoading(true);
            const loadingTitle = nextPageToken
                ? 'Loading more results from Jira'
                : `Loading more results starting at ${nextStartAt}`;
            updateLoadingProgress(loadingTitle, 'Fetching next page from Jira');

            try {
                await sprintFieldReady;
                const includeFields = new Set([SPRINT_FIELD_FALLBACK]);
                if (sprintFieldId) {
                    includeFields.add(sprintFieldId);
                }

                const payload = {
                    jql: lastExecutedJql,
                    maxResults: 100,
                    includeFields: Array.from(includeFields)
                };

                if (nextPageToken) {
                    payload.nextPageToken = nextPageToken;
                    payload.startAt = nextStartAt;
                } else {
                    payload.startAt = nextStartAt;
                }

                console.log('Requesting next search page with payload:', payload);

                const response = await fetch('http://localhost:3000/async/search', {
                    method: 'POST',
                    headers: {
                        'Content-Type': 'application/json'
                    },
                    body: JSON.stringify(payload),
                    signal
                });

                const meta = await response.json();
                console.log('Next page async response:', meta);

                if (meta.error) {
                    throw new Error(meta.error);
                }

                if (response.status === 200 && meta?.data) {
                    await finalizeSearchData(meta.data, {
                        signal,
                        requestId: meta.requestId,
                        source: 'cache:page',
                        meta: meta.meta,
                        merge: true
                    });
                    if (!hasSearchBeenCancelled()) {
                        showLoading(false);
                    }
                    return;
                }

                if (response.status === 202 && meta?.requestId) {
                    attachSearchStream(meta, { signal, merge: true });
                    return;
                }

                throw new Error(`Unexpected async search response for pagination: ${response.status}`);
            } catch (error) {
                if (error.name === 'AbortError' || hasSearchBeenCancelled()) {
                    console.log('Pagination request aborted:', error.message || error);
                } else {
                    console.error('Failed to load additional results:', error);
                    showDashboardToast(error.message || 'Unable to load more results', 'error');
                }
            } finally {
                if (!hasSearchBeenCancelled() && !currentSearchStream) {
                    showLoading(false);
                }
            }
        }

        function updatePaginationControls(epicCount) {
            const container = document.getElementById('asyncPaginationContainer');
            if (!container) {
                return;
            }

            if (currentSearchMeta && currentSearchMeta.hasMore) {
                const loadedIssues = Array.isArray(searchData) ? searchData.length : epicCount;
                const totalIsKnown = Number.isFinite(currentSearchMeta.total) && currentSearchMeta.total >= 0;
                const totalText = totalIsKnown
                    ? `${currentSearchMeta.total}`
                    : 'more';
                const progressText = totalIsKnown
                    ? `Loaded ${loadedIssues} of ${totalText} issues so far`
                    : `Loaded ${loadedIssues} issues so far (more available)`;
                container.innerHTML = `
                    <button class="load-more-button" onclick="requestNextSearchPage()" style="
                        background: #2563eb;
                        color: white;
                        border: none;
                        border-radius: 8px;
                        padding: 10px 18px;
                        font-weight: 600;
                        cursor: pointer;
                        box-shadow: 0 10px 25px rgba(37, 99, 235, 0.25);
                        transition: transform 0.2s ease, box-shadow 0.2s ease;
                    " onmouseover="this.style.transform='translateY(-1px)'; this.style.boxShadow='0 12px 28px rgba(37,99,235,0.3)';" onmouseout="this.style.transform=''; this.style.boxShadow='0 10px 25px rgba(37,99,235,0.25)';">
                        Load More Results
                    </button>
                    <div style="margin-top: 8px; color: #4b5563; font-size: 13px;">
                        ${progressText}
                    </div>
                `;
            } else if (currentSearchMeta && Number.isFinite(currentSearchMeta.total)) {
                container.innerHTML = `
                    <div style="color: #4b5563; font-size: 13px;">
                        Showing all ${currentSearchMeta.total} issues
                    </div>
                `;
            } else {
                container.innerHTML = '';
            }
        }

        function groupStoriesByEpic(stories) {
            const map = new Map();
            if (!Array.isArray(stories)) {
                return map;
            }

            for (const story of stories) {
                const epicKey = story?.fields?.customfield_10014 || story?.fields?.parent?.key;
                if (!epicKey) {
                    continue;
                }
                if (!map.has(epicKey)) {
                    map.set(epicKey, []);
                }
                map.get(epicKey).push(story);
            }

            return map;
        }

        function mergeIssuesByKey(existing = [], incoming = []) {
            const merged = [];
            const seen = new Set();

            for (const issue of [...existing, ...incoming]) {
                const issueKey = issue?.key;
                if (!issueKey || seen.has(issueKey)) {
                    continue;
                }
                merged.push(issue);
                seen.add(issueKey);
            }

            return merged;
        }

        async function ensureEpicsPresent(issues = [], options = {}) {
            if (!Array.isArray(issues) || issues.length === 0 || hasSearchBeenCancelled()) {
                return issues;
            }

            const { signal } = options;
            const fetchOptions = signal ? { signal } : {};
            const isEpicIssue = (issue) => {
                const typeName = issue?.fields?.issuetype?.name;
                return typeof typeName === 'string' && typeName.toLowerCase().includes('epic');
            };

            const existingEpicKeys = new Set();
            const referencedEpicKeys = new Set();

            for (const issue of issues) {
                if (!issue) {
                    continue;
                }

                if (issue.key && isEpicIssue(issue)) {
                    existingEpicKeys.add(issue.key);
                }

                const epicLink = issue?.fields?.customfield_10014;
                if (epicLink) {
                    referencedEpicKeys.add(epicLink);
                }

                const parentKey = issue?.fields?.parent?.key;
                if (parentKey) {
                    referencedEpicKeys.add(parentKey);
                }
            }

            const keysToFetch = [...referencedEpicKeys].filter(key => key && !existingEpicKeys.has(key));
            if (keysToFetch.length === 0 || hasSearchBeenCancelled()) {
                return issues;
            }

            const fetchedEpics = [];
            const chunkSize = 20;

            try {
                const epicChunks = chunkArray(keysToFetch, chunkSize);
                for (const chunk of epicChunks) {
                    if (!Array.isArray(chunk) || chunk.length === 0 || hasSearchBeenCancelled()) {
                        break;
                    }

                    const formattedKeys = chunk.map(key => `"${key}"`).join(', ');
                    const jql = `key in (${formattedKeys}) AND issuetype in ("Epic", "Epic (Feature)")`;
                    const searchUrl = new URL('http://localhost:3000/search');
                    searchUrl.searchParams.set('jql', jql);

                    const response = await fetch(searchUrl, fetchOptions);
                    if (!response.ok) {
                        throw new Error(`Epic fetch failed with status ${response.status}`);
                    }

                    const data = await response.json();
                    if (Array.isArray(data?.issues) && data.issues.length > 0) {
                        fetchedEpics.push(...data.issues);
                    }
                }
            } catch (error) {
                if (error?.name === 'AbortError' || hasSearchBeenCancelled()) {
                    console.log('Epic enrichment aborted.');
                    return issues;
                }
                console.warn('Unable to enrich results with epics:', error);
                return issues;
            }

            if (fetchedEpics.length === 0) {
                return issues;
            }

            return mergeIssuesByKey(issues, fetchedEpics);
        }

        async function processAndDisplayResults(options = {}) {

            if (hasSearchBeenCancelled()) {
                console.log('Skipping result rendering because the search was cancelled.');
                return;
            }

            if (searchData.length === 0) {
                showEmptyResults();
                return;
            }

            // Debug: log all issue types found
            const issueTypes = [...new Set(searchData.map(issue => issue.fields.issuetype.name))];
            console.log('Found issue types:', issueTypes);
            console.log('Total issues:', searchData.length);

            const epics = searchData.filter(issue => 
                issue.fields.issuetype.name === 'Epic' || 
                issue.fields.issuetype.name === 'Epic (Feature)' ||
                issue.fields.issuetype.name.toLowerCase().includes('epic')
            );
            const stories = searchData.filter(issue => issue.fields.issuetype.name === 'Story');

            console.log('Filtered epics:', epics.length);
            console.log('Filtered stories:', stories.length);

            await enrichStoriesWithSprint(stories, options);

            if (hasSearchBeenCancelled()) {
                console.log('Stopped after sprint enrichment due to cancellation.');
                return;
            }

            const initialStoryMap = groupStoriesByEpic(stories);
            const resultsContent = document.getElementById('resultsContent');
            if (!resultsContent) {
                console.warn('Results container not found.');
                return;
            }

            let resultsHtml = `
                <div class="stats-summary">
                    <div class="stat-item">
                        <div class="stat-number">${epics.length}</div>
                        <div class="stat-label">Features (Epics)</div>
                    </div>
                </div>
                <div id="epicCardsContainer"></div>
                <div id="asyncPaginationContainer" style="margin-top: 24px;"></div>
            `;

            const orphanedStories = stories.filter(story => 
                !story.fields.customfield_10014 || 
                !epics.some(epic => epic.key === story.fields.customfield_10014)
            );

            if (orphanedStories.length > 0) {
                resultsHtml += createOrphanedStoriesCard(orphanedStories);
            }

            if (hasSearchBeenCancelled()) {
                console.log('Skipping UI update because the search was cancelled.');
                return;
            }

            resultsContent.innerHTML = resultsHtml;

            const epicCardsContainer = document.getElementById('epicCardsContainer');
            if (!epicCardsContainer) {
                console.warn('Epic cards container not found.');
                return;
            }

            const epicStates = new Map();
            let processedCount = 0;

            for (const epic of epics) {
                if (hasSearchBeenCancelled()) {
                    console.log('Halting epic processing because the search was cancelled.');
                    return;
                }

                processedCount++;
                const loadingDiv = document.getElementById('loadingState');
                if (!hasSearchBeenCancelled() && loadingDiv && loadingDiv.style.display === 'block') {
                    loadingDiv.innerHTML = `
                        <div class="spinner"></div>
                        <h3>Processing Epics... (${processedCount}/${epics.length})</h3>
                        <p>Please wait while we fetch epic details</p>
                    `;
                }

                const initialStories = mergeIssuesByKey(initialStoryMap.get(epic.key) || []);
                const state = {
                    stories: initialStories,
                    storiesLoading: true,
                    bugs: [],
                    bugsLoading: true
                };
                epicStates.set(epic.key, state);
                if (window.currentEpicsWithStories) {
                    window.currentEpicsWithStories[epic.key] = initialStories;
                }

                const cardHtml = createEpicCard(epic, initialStories, [], {
                    storiesLoading: state.storiesLoading,
                    bugsLoading: state.bugsLoading
                });
                epicCardsContainer.insertAdjacentHTML('beforeend', cardHtml);
            }

            showResults();

            if (epics.length === 0) {
                return;
            }

            const updateStoriesForEpics = async () => {
                try {
                    const epicStoriesMap = await fetchStoriesForEpics(epics, options);
                    if (hasSearchBeenCancelled()) {
                        console.log('Skipping story updates because the search was cancelled.');
                        return;
                    }

                    for (const epic of epics) {
                        const state = epicStates.get(epic.key);
                        if (!state) {
                            continue;
                        }
                        state.stories = mergeIssuesByKey(state.stories, epicStoriesMap.get(epic.key) || []);
                        state.storiesLoading = false;
                        if (window.currentEpicsWithStories) {
                            window.currentEpicsWithStories[epic.key] = state.stories;
                        }
                        updateEpicStoriesUI(epic.key, state);
                    }

                    for (const [epicKey, state] of epicStates.entries()) {
                        if (!epicStoriesMap.has(epicKey)) {
                            state.storiesLoading = false;
                            updateEpicStoriesUI(epicKey, state);
                        }
                    }
                } catch (error) {
                    if (error?.name === 'AbortError' || hasSearchBeenCancelled()) {
                        console.log('Story fetch update aborted.');
                        return;
                    }
                    console.error('Failed to fetch stories for epics:', error);
                    for (const [epicKey, state] of epicStates.entries()) {
                        state.storiesLoading = false;
                        updateEpicStoriesUI(epicKey, state);
                    }
                }
            };

            const updateBugsForEpics = async () => {
                try {
                    const epicBugsMap = await fetchBugsForEpics(epics, options);
                    if (hasSearchBeenCancelled()) {
                        console.log('Skipping bug updates because the search was cancelled.');
                        return;
                    }

                    for (const epic of epics) {
                        const state = epicStates.get(epic.key);
                        if (!state) {
                            continue;
                        }
                        state.bugs = mergeIssuesByKey(state.bugs, epicBugsMap.get(epic.key) || []);
                        state.bugsLoading = false;
                        updateEpicBugsUI(epic.key, state);
                    }

                    for (const [epicKey, state] of epicStates.entries()) {
                        if (!epicBugsMap.has(epicKey)) {
                            state.bugsLoading = false;
                            updateEpicBugsUI(epicKey, state);
                        }
                    }
                } catch (error) {
                    if (error?.name === 'AbortError' || hasSearchBeenCancelled()) {
                        console.log('Bug fetch update aborted.');
                        return;
                    }
                    console.error('Failed to fetch bugs for epics:', error);
                    for (const [epicKey, state] of epicStates.entries()) {
                        state.bugsLoading = false;
                        updateEpicBugsUI(epicKey, state);
                    }
                }
            };

            updateStoriesForEpics();
            updateBugsForEpics();
            updatePaginationControls(epics.length);
        }

        function chunkArray(items, size) {
            if (!Array.isArray(items) || size <= 0) {
                return [];
            }
            const chunks = [];
            for (let index = 0; index < items.length; index += size) {
                chunks.push(items.slice(index, index + size));
            }
            return chunks;
        }

        async function fetchStoriesForEpics(epics, options = {}) {
            const storyMap = new Map();

            if (!Array.isArray(epics) || epics.length === 0) {
                return storyMap;
            }

            const epicKeys = [...new Set(epics.map(epic => epic?.key).filter(Boolean))];
            epicKeys.forEach(key => storyMap.set(key, []));

            if (epicKeys.length === 0) {
                return storyMap;
            }

            const { signal } = options;
            const fetchOptions = signal ? { signal } : {};
            const collectedStories = [];
            const chunkSize = 20;

            try {
                await sprintFieldReady;

                const chunkPromises = chunkArray(epicKeys, chunkSize).map(async chunk => {
                    if (hasSearchBeenCancelled()) {
                        return [];
                    }

                    const formattedKeys = chunk.map(key => `"${key}"`).join(', ');
                    const jql = `"Epic Link" in (${formattedKeys}) AND issuetype = Story`;
                    const searchUrl = new URL('http://localhost:3000/search');
                    searchUrl.searchParams.set('jql', jql);

                    const includeFields = new Set([SPRINT_FIELD_FALLBACK]);
                    if (sprintFieldId) {
                        includeFields.add(sprintFieldId);
                    }
                    searchUrl.searchParams.set('includeFields', Array.from(includeFields).join(','));

                    const response = await fetch(searchUrl, fetchOptions);
                    if (!response.ok) {
                        throw new Error(`Story batch fetch failed with status ${response.status}`);
                    }

                    const data = await response.json();
                    return data.issues || [];
                });

                const chunkResults = await Promise.all(chunkPromises);

                if (hasSearchBeenCancelled()) {
                    return storyMap;
                }
                chunkResults.forEach(issues => {
                    if (Array.isArray(issues) && issues.length > 0) {
                        collectedStories.push(...issues);
                    }
                });

                await enrichStoriesWithSprint(collectedStories, options);

                for (const story of collectedStories) {
                    const epicLink = story?.fields?.customfield_10014 || story?.fields?.parent?.key;
                    if (!epicLink) {
                        continue;
                    }
                    if (!storyMap.has(epicLink)) {
                        storyMap.set(epicLink, []);
                    }
                    storyMap.get(epicLink).push(story);
                }

                return storyMap;
            } catch (error) {
                console.warn('Batch story fetch failed, falling back to per-epic strategy:', error);
                return fetchStoriesForEpicsSerial(epics, options, storyMap);
            }
        }

        async function fetchStoriesForEpicsSerial(epics, options = {}, seedMap = new Map()) {
            const storyMap = new Map(seedMap);

            if (!Array.isArray(epics) || epics.length === 0) {
                return storyMap;
            }

            const chunkSize = 5;
            for (let index = 0; index < epics.length && !hasSearchBeenCancelled(); index += chunkSize) {
                const chunk = epics.slice(index, index + chunkSize);
                const chunkPromises = chunk.map(epic => (async () => {
                    const stories = await fetchStoriesForSingleEpic(epic.key, options);
                    return { key: epic.key, stories };
                })());

                const settledResults = await Promise.allSettled(chunkPromises);

                settledResults.forEach(result => {
                    if (result.status === 'fulfilled' && result.value) {
                        const key = result.value.key;
                        if (!storyMap.has(key)) {
                            storyMap.set(key, []);
                        }
                        storyMap.set(key, result.value.stories || []);
                    } else if (result.status === 'rejected') {
                        const reason = result.reason;
                        if (reason?.name === 'AbortError' || hasSearchBeenCancelled()) {
                            console.log('Story chunk fetch aborted.');
                        } else {
                            console.error('Story chunk fetch failed:', reason);
                        }
                    }
                });
            }

            return storyMap;
        }

        async function fetchStoriesForSingleEpic(epicKey, options = {}) {
            if (hasSearchBeenCancelled()) {
                return [];
            }

            try {
                const jql = `"Epic Link" = ${epicKey} AND issuetype = Story`;
                await sprintFieldReady;
                if (hasSearchBeenCancelled()) {
                    return [];
                }

                const searchUrl = new URL('http://localhost:3000/search');
                searchUrl.searchParams.set('jql', jql);
                const includeFields = new Set([SPRINT_FIELD_FALLBACK]);
                if (sprintFieldId) {
                    includeFields.add(sprintFieldId);
                }
                searchUrl.searchParams.set('includeFields', Array.from(includeFields).join(','));

                const { signal } = options;
                const fetchOptions = signal ? { signal } : {};
                const response = await fetch(searchUrl, fetchOptions);
                if (!response.ok) {
                    throw new Error(`Story fetch failed with status ${response.status}`);
                }

                const data = await response.json();
                const stories = data.issues || [];
                await enrichStoriesWithSprint(stories, options);
                return stories;
            } catch (error) {
                if (error.name === 'AbortError' || hasSearchBeenCancelled()) {
                    console.log(`Story fetch aborted for epic ${epicKey}.`);
                    return [];
                }
                console.error(`Error fetching stories for epic ${epicKey}:`, error);
                return [];
            }
        }

        async function fetchBugsForEpics(epics, options = {}) {
            const bugMap = new Map();

            if (!Array.isArray(epics) || epics.length === 0) {
                return bugMap;
            }

            const epicKeys = [...new Set(epics.map(epic => epic?.key).filter(Boolean))];
            epicKeys.forEach(key => bugMap.set(key, []));

            if (epicKeys.length === 0) {
                return bugMap;
            }

            const { signal } = options;
            const fetchOptions = signal ? { signal } : {};
            const chunkSize = 20;

            try {
                const chunkPromises = chunkArray(epicKeys, chunkSize).map(async chunk => {
                    if (hasSearchBeenCancelled()) {
                        return [];
                    }

                    const formattedKeys = chunk.map(key => `"${key}"`).join(', ');
                    const jql = `"Epic Link" in (${formattedKeys}) AND issuetype = Bug`;
                    const response = await fetch(`http://localhost:3000/search?jql=${encodeURIComponent(jql)}`, fetchOptions);
                    if (!response.ok) {
                        throw new Error(`Bug batch fetch failed with status ${response.status}`);
                    }

                    const data = await response.json();
                    return data.issues || [];
                });

                const chunkResults = await Promise.all(chunkPromises);

                if (hasSearchBeenCancelled()) {
                    return bugMap;
                }
                chunkResults.forEach(issues => {
                    if (!Array.isArray(issues)) {
                        return;
                    }
                    for (const bug of issues) {
                        const epicLink = bug?.fields?.customfield_10014 || bug?.fields?.parent?.key;
                        if (!epicLink) {
                            continue;
                        }
                        if (!bugMap.has(epicLink)) {
                            bugMap.set(epicLink, []);
                        }
                        bugMap.get(epicLink).push(bug);
                    }
                });

                return bugMap;
            } catch (error) {
                console.warn('Batch bug fetch failed, falling back to per-epic strategy:', error);
                return fetchBugsForEpicsSerial(epics, options, bugMap);
            }
        }

        async function fetchBugsForEpicsSerial(epics, options = {}, seedMap = new Map()) {
            const bugMap = new Map(seedMap);

            if (!Array.isArray(epics) || epics.length === 0) {
                return bugMap;
            }

            const chunkSize = 5;
            for (let index = 0; index < epics.length && !hasSearchBeenCancelled(); index += chunkSize) {
                const chunk = epics.slice(index, index + chunkSize);
                const chunkPromises = chunk.map(epic => (async () => {
                    const bugs = await getBugsForEpic(epic.key, [], options);
                    return { key: epic.key, bugs };
                })());

                const settledResults = await Promise.allSettled(chunkPromises);

                settledResults.forEach(result => {
                    if (result.status === 'fulfilled' && result.value) {
                        const key = result.value.key;
                        if (!bugMap.has(key)) {
                            bugMap.set(key, []);
                        }
                        bugMap.set(key, result.value.bugs || []);
                    } else if (result.status === 'rejected') {
                        const reason = result.reason;
                        if (reason?.name === 'AbortError' || hasSearchBeenCancelled()) {
                            console.log('Bug chunk fetch aborted.');
                        } else {
                            console.error('Bug chunk fetch failed:', reason);
                        }
                    }
                });
            }

            return bugMap;
        }

        async function getStoriesForEpic(epicKey, options = {}) {
            const stories = await fetchStoriesForSingleEpic(epicKey, options);
            if (!window.currentEpicsWithStories) {
                window.currentEpicsWithStories = {};
            }
            window.currentEpicsWithStories[epicKey] = stories;
            return stories;
        }

        async function enrichStoriesWithSprint(stories, options = {}) {
            if (!Array.isArray(stories) || stories.length === 0 || hasSearchBeenCancelled()) {
                return stories;
            }

            await sprintFieldReady;
            if (hasSearchBeenCancelled()) {
                return stories;
            }

            const { signal } = options;
            const fetchOptions = signal ? { signal } : {};

            const storiesNeedingSprint = stories.filter(story => {
                if (!story || !story.fields) {
                    return false;
                }

                const cachedSprintValue = sprintFieldCache.get(story.key);
                if (cachedSprintValue && !story.fields[sprintFieldId]) {
                    story.fields[sprintFieldId] = cachedSprintValue;
                    if (sprintFieldId !== SPRINT_FIELD_FALLBACK) {
                        story.fields[SPRINT_FIELD_FALLBACK] = cachedSprintValue;
                    }
                }

                const sprintFieldValue = story.fields[sprintFieldId] ?? story.fields[SPRINT_FIELD_FALLBACK];
                const hasSprint = !!getLatestSprintName(sprintFieldValue);
                if (!hasSprint) {
                    console.log(`Sprint missing for ${story.key}`, {
                        resolvedFieldId: sprintFieldId,
                        fallbackField: SPRINT_FIELD_FALLBACK,
                        resolvedValue: story.fields[sprintFieldId],
                        fallbackValue: story.fields[SPRINT_FIELD_FALLBACK]
                    });
                }
                return !hasSprint;
            });

            if (storiesNeedingSprint.length === 0) {
                return stories;
            }

            console.log(`Enriching ${storiesNeedingSprint.length} stories with sprint data`);

            for (const story of storiesNeedingSprint) {
                if (hasSearchBeenCancelled()) {
                    console.log('Stopped sprint enrichment loop due to cancellation.');
                    return stories;
                }

                try {
                    const detailsUrl = new URL(`http://localhost:3000/issue/${story.key}`);
                    const fieldsToRequest = new Set([SPRINT_FIELD_FALLBACK]);
                    if (sprintFieldId) {
                        fieldsToRequest.add(sprintFieldId);
                    }
                    detailsUrl.searchParams.set('fields', Array.from(fieldsToRequest).join(','));

                    const response = await fetch(detailsUrl, fetchOptions);
                    if (!response.ok) {
                        throw new Error(`Sprint enrichment failed with status ${response.status}`);
                    }

                    const detailedStory = await response.json();
                    const detailedSprintValue = detailedStory?.fields?.[sprintFieldId] ?? detailedStory?.fields?.[SPRINT_FIELD_FALLBACK];
                    console.log(`Detailed sprint payload for ${story.key}`, {
                        sprintFieldId,
                        fallbackField: SPRINT_FIELD_FALLBACK,
                        detailedResolvedValue: detailedStory?.fields?.[sprintFieldId],
                        detailedFallbackValue: detailedStory?.fields?.[SPRINT_FIELD_FALLBACK]
                    });
                    let sprintValueToApply = detailedSprintValue;

                    if (!sprintValueToApply) {
                        sprintValueToApply = await fetchAgileSprintValue(story.key, options);
                        console.log(`Agile sprint payload for ${story.key}`, sprintValueToApply);
                    }

                    if (sprintValueToApply) {
                        const normalizedSprintValue = Array.isArray(sprintValueToApply)
                            ? sprintValueToApply
                            : [sprintValueToApply];

                        story.fields[sprintFieldId] = normalizedSprintValue;
                        if (sprintFieldId !== SPRINT_FIELD_FALLBACK) {
                            story.fields[SPRINT_FIELD_FALLBACK] = normalizedSprintValue;
                        }
                        sprintFieldCache.set(story.key, normalizedSprintValue);
                    } else {
                        console.warn(`Sprint enrichment returned no data for ${story.key}`);
                    }
                } catch (error) {
                    console.warn(`Unable to enrich sprint info for ${story?.key}:`, error);
                }
            }

            return stories;
        }

        async function fetchAgileSprintValue(issueKey, options = {}) {
            if (hasSearchBeenCancelled()) {
                return null;
            }

            try {
                const agileUrl = new URL(`http://localhost:3000/agile/issue/${issueKey}`);
                const { signal } = options;
                const fetchOptions = signal ? { signal } : {};
                const response = await fetch(agileUrl, fetchOptions);
                if (!response.ok) {
                    throw new Error(`Agile sprint fetch failed with status ${response.status}`);
                }

                const agileData = await response.json();
                const sprintCandidates = [];

                if (agileData?.fields?.sprint) {
                    sprintCandidates.push(agileData.fields.sprint);
                }

                if (Array.isArray(agileData?.fields?.sprints)) {
                    sprintCandidates.push(...agileData.fields.sprints);
                }

                if (Array.isArray(agileData?.fields?.openSprints)) {
                    sprintCandidates.push(...agileData.fields.openSprints);
                }

                if (Array.isArray(agileData?.fields?.closedSprints)) {
                    sprintCandidates.push(...agileData.fields.closedSprints);
                }

                if (sprintCandidates.length === 0) {
                    return null;
                }

                return sprintCandidates;
            } catch (error) {
                if (error.name === 'AbortError' || hasSearchBeenCancelled()) {
                    console.log(`Agile sprint lookup aborted for ${issueKey}.`);
                    return null;
                }
                console.warn(`Agile sprint lookup failed for ${issueKey}:`, error);
                return null;
            }
        }

        async function getBugsForEpic(epicKey, stories = [], options = {}) {
            if (hasSearchBeenCancelled()) {
                return [];
            }

            let allBugs = [];
            const { signal } = options;
            const fetchOptions = signal ? { signal } : {};
            
            // Get bugs directly linked to epic (this is fast)
            try {
                const epicBugsJql = `"Epic Link" = ${epicKey} AND issuetype = Bug`;
                const epicBugsResponse = await fetch(`http://localhost:3000/search?jql=${encodeURIComponent(epicBugsJql)}`, fetchOptions);
                const epicBugsData = await epicBugsResponse.json();
                if (epicBugsData.issues) {
                    allBugs = allBugs.concat(epicBugsData.issues);
                }
            } catch (error) {
                if (error.name === 'AbortError' || hasSearchBeenCancelled()) {
                    console.log(`Bug fetch aborted for epic ${epicKey}.`);
                    return allBugs;
                }
                console.error(`Error fetching bugs for epic ${epicKey}:`, error);
            }

            // Skip the individual story issue link checking for now to speed up the display
            // This was causing hundreds of API calls and making the dashboard very slow
            // TODO: Implement this as a background process or optimize the query

            return allBugs;
        }

        function createBugCard(bug) {
            return `
                <div class="bug-card" style="background: #fef5e7; border: 1px solid #f6ad55; border-radius: 8px; padding: 12px; margin: 8px 0;">
                    <div class="bug-header" style="display: flex; align-items: center; margin-bottom: 8px;">
                        <div class="bug-key" style="background: #ed8936; color: white; padding: 2px 8px; border-radius: 4px; font-size: 12px; font-weight: bold; margin-right: 10px; cursor: pointer;" 
                             onclick="openJiraIssue('${bug.key}')" 
                             title="Click to open ${bug.key} in JIRA">
                            <i class="fas fa-bug" style="margin-right: 4px;"></i>${bug.key}
                        </div>
                        <div class="bug-priority" style="font-size: 12px; color: #744210;">
                            Priority: ${bug.fields.priority ? bug.fields.priority.name : 'Not Set'}
                        </div>
                    </div>
                    <div class="bug-title" style="font-weight: 600; color: #744210; margin-bottom: 8px; line-height: 1.4;">
                        ${bug.fields.summary}
                    </div>
                    <div class="bug-details" style="display: flex; justify-content: space-between; align-items: center; font-size: 13px; color: #975a16;">
                        <div class="bug-status">
                            <i class="fas fa-info-circle" style="margin-right: 4px;"></i>Status: ${bug.fields.status.name}
                        </div>
                        <div class="bug-assignee">
                            <i class="fas fa-user" style="margin-right: 4px;"></i>Assignee: ${bug.fields.assignee ? bug.fields.assignee.displayName : 'Unassigned'}
                        </div>
                    </div>
                </div>
            `;
        }

        function renderFeatureActions(epicKey, stories, storiesLoading) {
            const hasStories = Array.isArray(stories) && stories.length > 0;

            if (hasStories) {
                return `
                    <button class="email-button" onclick="event.stopPropagation(); sendEmailsDirectly('${epicKey}')" 
                        title="Send email notifications for each story (TO: Assignee, CC: Reporter)">
                        <i class="fas fa-envelope"></i>
                        📧 Email Notification
                    </button>
                `;
            }

            if (storiesLoading) {
                return '<span style="background: #ebf5ff; color: #1d4ed8; padding: 6px 10px; border-radius: 6px; font-size: 12px; font-weight: 600;">Loading stories...</span>';
            }

            return '';
        }

        function renderStoriesSectionInnerHtml(stories, storiesLoading) {
            const hasStories = Array.isArray(stories) && stories.length > 0;

            if (!hasStories && storiesLoading) {
                return '<div style="color: #6b7280; font-style: italic;">Loading stories...</div>';
            }

            if (!hasStories) {
                return '<div style="color: #6b7280; font-style: italic;">No stories found for this feature</div>';
            }

            const storyItems = stories.map(story => createStoryListItem(story)).join('');
            const loadingMessage = storiesLoading
                ? '<div style="color: #6b7280; font-style: italic; margin-top: 8px;">Loading additional stories...</div>'
                : '';

            return `
                <div class="story-list">
                    ${storyItems}
                </div>
                ${loadingMessage}
            `;
        }

        function renderBugsSectionInnerHtml(bugs, bugsLoading) {
            if (bugsLoading) {
                return '<div style="color: #6b7280; font-style: italic;">Loading bugs...</div>';
            }

            if (!Array.isArray(bugs) || bugs.length === 0) {
                return '<div style="color: #6b7280; font-style: italic;">No bugs found for this feature</div>';
            }

            return `
                <div class="bug-list">
                    ${bugs.map(bug => createBugCard(bug)).join('')}
                </div>
            `;
        }

        function createEpicCard(epic, stories, bugs, options = {}) {
            const { storiesLoading = false, bugsLoading = false } = options;
            const bugCount = Array.isArray(bugs) ? bugs.length : 0;
            const storyCount = Array.isArray(stories) ? stories.length : 0;
            const hasStories = storyCount > 0;
            const storyCountLabel = storiesLoading && !hasStories ? 'Loading...' : `${storyCount} ${storyCount === 1 ? 'story' : 'stories'}`;
            const bugCountLabel = bugsLoading ? 'Loading...' : `${bugCount} total count`;
            const actionsHtml = renderFeatureActions(epic.key, stories, storiesLoading);
            const cardId = `feature-card-${epic.key}`;

            // Extract Epic Feature Number from various possible fields
            let featureNumber = '';
            let featureInfo = '';
            
            // Check fixVersions first (most common for feature versions)
            if (epic.fields.fixVersions && epic.fields.fixVersions.length > 0) {
                featureNumber = epic.fields.fixVersions[0].name;
                featureInfo = `Fix Version: ${featureNumber}`;
            }
            // Check various custom fields that might contain feature numbers
            else if (epic.fields.customfield_10004) {
                featureNumber = epic.fields.customfield_10004;
                featureInfo = `Feature: ${featureNumber}`;
            }
            else if (epic.fields.customfield_10005) {
                featureNumber = epic.fields.customfield_10005;
                featureInfo = `Feature: ${featureNumber}`;
            }
            else if (epic.fields.customfield_10006) {
                featureNumber = epic.fields.customfield_10006;
                featureInfo = `Feature: ${featureNumber}`;
            }
            else if (epic.fields.customfield_10014) {
                featureNumber = epic.fields.customfield_10014;
                featureInfo = `Epic Link: ${featureNumber}`;
            }
            else if (epic.fields.customfield_10020) {
                featureNumber = epic.fields.customfield_10020;
                featureInfo = `Feature: ${featureNumber}`;
            }
            else if (epic.fields.customfield_10021) {
                featureNumber = epic.fields.customfield_10021;
                featureInfo = `Feature: ${featureNumber}`;
            }
            else if (epic.fields.customfield_10022) {
                featureNumber = epic.fields.customfield_10022;
                featureInfo = `Feature: ${featureNumber}`;
            }
            
            // Debug logging to see all available fields
            console.log('Epic debugging:', {
                key: epic.key,
                summary: epic.fields.summary,
                fixVersions: epic.fields.fixVersions,
                customfield_10004: epic.fields.customfield_10004,
                customfield_10005: epic.fields.customfield_10005,
                customfield_10006: epic.fields.customfield_10006,
                customfield_10014: epic.fields.customfield_10014,
                customfield_10020: epic.fields.customfield_10020,
                customfield_10021: epic.fields.customfield_10021,
                customfield_10022: epic.fields.customfield_10022,
                customfield_10221: epic.fields.customfield_10221,
                detectedFeature: featureNumber
            });

            return `
                <div class="feature-card" id="${cardId}" data-epic-key="${epic.key}">
                    <div class="feature-header" onclick="toggleFeature(this)">
                        <div class="feature-title">
                            <i class="fas fa-plus-circle feature-toggle-icon" style="color: #3182ce; margin-right: 8px; transition: transform 0.3s ease;"></i>
                            <strong>Feature - ${epic.key}: ${epic.fields.summary}</strong>
                        </div>
                        <div class="feature-actions" id="feature-actions-${epic.key}" style="display: flex; align-items: center; gap: 8px;">
                            ${actionsHtml}
                        </div>
                    </div>
                    <div class="feature-details">
                        <div class="feature-branch-structure">
                            <!-- Benefit Hypothesis -->
                            ${epic.fields.customfield_10221 ? `
                            <div class="branch-item" style="margin-top: 15px;">
                                <i class="fas fa-plus" style="color: #22c55e; margin-right: 8px;"></i>
                                <strong>Benefit Hypothesis</strong>
                                <div class="sub-details" style="margin-left: 24px; margin-top: 8px; background: #f0f9ff; padding: 12px; border-radius: 8px; border-left: 4px solid #3182ce;">
                                    <p style="margin: 0; color: #1e40af; line-height: 1.6;">${epic.fields.customfield_10221}</p>
                                </div>
                            </div>
                            ` : ''}

                            <!-- Stories -->
                            <div class="branch-item" style="margin-top: 15px;">
                                <span onclick="toggleSection(this, 'stories')" style="cursor: pointer; display: inline-flex; align-items: center;">
                                    <i class="fas fa-plus section-toggle-icon" style="color: #22c55e; margin-right: 8px; transition: transform 0.3s ease;"></i>
                                    <strong>Stories = <span id="stories-count-${epic.key}">${storyCountLabel}</span></strong>
                                </span>
                                <div class="sub-details stories-section" id="stories-section-${epic.key}" style="margin-left: 24px; margin-top: 10px; display: none;">
                                    ${renderStoriesSectionInnerHtml(stories, storiesLoading)}
                                </div>
                            </div>

                            <!-- Bugs -->
                            <div class="branch-item" style="margin-top: 15px;">
                                <span onclick="toggleSection(this, 'bugs')" style="cursor: pointer; display: inline-flex; align-items: center;">
                                    <i class="fas fa-plus section-toggle-icon" style="color: #22c55e; margin-right: 8px; transition: transform 0.3s ease;"></i>
                                    <strong>Bugs = <span id="bugs-count-${epic.key}">${bugCountLabel}</span></strong>
                                </span>
                                <div class="sub-details bugs-section" id="bugs-section-${epic.key}" style="margin-left: 24px; margin-top: 10px; display: none;">
                                    ${renderBugsSectionInnerHtml(bugs, bugsLoading)}
                                </div>
                            </div>

                            <!-- Capability Number -->
                            ${epic.fields.parent ? `
                            <div class="branch-item" style="margin-top: 15px;">
                                <i class="fas fa-plus" style="color: #22c55e; margin-right: 8px;"></i>
                                <strong>Capability Number</strong>
                                <div class="sub-details" style="margin-left: 24px; margin-top: 8px;">
                                    <span style="background: #dbeafe; color: #1e40af; padding: 6px 12px; border-radius: 6px; font-weight: 600;">${epic.fields.parent.key}</span>
                                    ${epic.fields.parent.fields && epic.fields.parent.fields.summary ? ` - ${epic.fields.parent.fields.summary}` : ''}
                                </div>
                            </div>
                            ` : ''}
                        </div>
                    </div>
                </div>
            `;
        }

        function updateEpicStoriesUI(epicKey, state) {
            if (!state || hasSearchBeenCancelled()) {
                return;
            }

            const storyCountElement = document.getElementById(`stories-count-${epicKey}`);
            if (storyCountElement) {
                const storyCount = Array.isArray(state.stories) ? state.stories.length : 0;
                const label = state.storiesLoading && storyCount === 0
                    ? 'Loading...'
                    : `${storyCount} ${storyCount === 1 ? 'story' : 'stories'}`;
                storyCountElement.textContent = label;
            }

            const storySection = document.getElementById(`stories-section-${epicKey}`);
            if (storySection) {
                storySection.innerHTML = renderStoriesSectionInnerHtml(state.stories, state.storiesLoading);
            }

            const actionsContainer = document.getElementById(`feature-actions-${epicKey}`);
            if (actionsContainer) {
                actionsContainer.innerHTML = renderFeatureActions(epicKey, state.stories, state.storiesLoading);
            }
        }

        function updateEpicBugsUI(epicKey, state) {
            if (!state || hasSearchBeenCancelled()) {
                return;
            }

            const bugCountElement = document.getElementById(`bugs-count-${epicKey}`);
            if (bugCountElement) {
                const bugCount = Array.isArray(state.bugs) ? state.bugs.length : 0;
                const label = state.bugsLoading ? 'Loading...' : `${bugCount} total count`;
                bugCountElement.textContent = label;
            }

            const bugSection = document.getElementById(`bugs-section-${epicKey}`);
            if (bugSection) {
                bugSection.innerHTML = renderBugsSectionInnerHtml(state.bugs, state.bugsLoading);
            }
        }

        function createOrphanedStoriesCard(stories) {
            return `
                <div class="feature-card">
                    <div class="feature-header" onclick="toggleFeature(this)">
                        <div class="feature-title">
                            <i class="fas fa-book-open"></i>
                            <strong>Orphaned Stories</strong> (${stories.length})
                        </div>
                        <i class="fas fa-chevron-down toggle-icon"></i>
                    </div>
                    <div class="feature-details">
                        <p style="color: #718096; margin-bottom: 20px;">Stories not linked to any epic in the current search results.</p>
                        <div class="story-list">
                            ${stories.map(story => createStoryListItem(story)).join('')}
                        </div>
                    </div>
                </div>
            `;
        }

        // Improved field validation based on actual JIRA field structures
        function isFieldEmpty(field, fieldName = 'unknown') {
            console.log(`Checking field ${fieldName}:`, field, 'Type:', typeof field);
            
            // Null or undefined - definitely empty
            if (field === null || field === undefined) {
                console.log(`${fieldName} is null/undefined, returning true`);
                return true;
            }
            
            if (typeof field === 'string') {
                const sanitized = field
                    .replace(/<[^>]*>/g, ' ') // strip HTML tags
                    .replace(/&nbsp;/gi, ' ') // normalize nbsp
                    .replace(/\s+/g, ' ')    // collapse whitespace
                    .trim();

                if (sanitized.length === 0) {
                    console.log(`${fieldName} is empty string after sanitizing, returning true`);
                    return true;
                }

                const placeholderRegex = /^(no (acceptance criteria|description)( defined)?[.!]?)$/i;
                if (placeholderRegex.test(sanitized)) {
                    console.log(`${fieldName} matches placeholder text (${sanitized}), returning true`);
                    return true;
                }

                console.log(`${fieldName} is non-empty string (${sanitized}), returning false`);
                return false;
            }
            
            // Empty array - empty
            if (Array.isArray(field) && field.length === 0) {
                console.log(`${fieldName} is empty array, returning true`);
                return true;
            }
            
            // Empty object - empty
            if (typeof field === 'object' && Object.keys(field).length === 0) {
                console.log(`${fieldName} is empty object, returning true`);
                return true;
            }
            
            // For all other cases (non-empty objects, arrays with content, etc.) - has content
            console.log(`${fieldName} has content, returning false`);
            return false;
        }

        // Helper function to determine story styling based on missing fields
        function getStoryStyles(story) {
            console.log('=== Checking story:', story.key, '===');
            console.log('Raw description field:', story.fields.description);
            console.log('Raw customfield_10056 field:', story.fields.customfield_10056);
            
            // Show the entire fields object structure for debugging
            console.log('All story fields keys:', Object.keys(story.fields));
            
            // Show detailed analysis
            console.log('Description analysis:');
            console.log('- Type:', typeof story.fields.description);
            console.log('- Is null/undefined:', story.fields.description == null);
            console.log('- Is empty string:', story.fields.description === '');
            console.log('- If object, keys:', story.fields.description && typeof story.fields.description === 'object' ? Object.keys(story.fields.description) : 'N/A');
            
            console.log('CustomField_10056 analysis:');
            console.log('- Type:', typeof story.fields.customfield_10056);
            console.log('- Is null/undefined:', story.fields.customfield_10056 == null);
            console.log('- Is empty string:', story.fields.customfield_10056 === '');
            console.log('- If object, keys:', story.fields.customfield_10056 && typeof story.fields.customfield_10056 === 'object' ? Object.keys(story.fields.customfield_10056) : 'N/A');
            
            const hasDescription = !isFieldEmpty(story.fields.description, 'description');
            const hasAcceptanceCriteria = !isFieldEmpty(story.fields.customfield_10056, 'customfield_10056');
            
            console.log(`Story ${story.key} - hasDescription:`, hasDescription, 'hasAcceptanceCriteria:', hasAcceptanceCriteria);
            
            // RESTORED LOGIC: If missing description OR acceptance criteria (or both), make it red
            const isMissingFields = !hasDescription || !hasAcceptanceCriteria;
            
            console.log(`Story ${story.key} - isMissingFields:`, isMissingFields);
            
            if (isMissingFields) {
                console.log(`Story ${story.key} - Applying RED styling`);
                return {
                    backgroundColor: '#fee2e2', // Light red background
                    borderColor: '#dc2626',     // Red border
                    hoverBackgroundColor: '#fecaca', // Slightly darker red on hover
                    hoverBorderColor: '#b91c1c'     // Darker red border on hover
                };
            } else {
                console.log(`Story ${story.key} - Applying NORMAL styling`);
                // Normal styling - both fields present
                return {
                    backgroundColor: 'white',
                    borderColor: '#e2e8f0',
                    hoverBackgroundColor: '#f8fafc',
                    hoverBorderColor: '#3182ce'
                };
            }
        }

        // Extracts the most relevant sprint name from varying JIRA formats
        function getLatestSprintName(sprintField) {
            if (!sprintField) {
                return null;
            }

            const parseEntry = (entry) => {
                if (!entry) {
                    return null;
                }

                if (typeof entry === 'string') {
                    const nameMatch = entry.match(/name=([^,\]]+)/);
                    if (nameMatch) {
                        return nameMatch[1].trim().replace(/^"|"$/g, '');
                    }
                    return entry.trim();
                }

                if (typeof entry === 'object') {
                    if (entry.name) {
                        return entry.name;
                    }

                    if (entry.displayName) {
                        return entry.displayName;
                    }

                    if (entry.value) {
                        return entry.value;
                    }
                }

                return null;
            };

            if (Array.isArray(sprintField)) {
                for (let i = sprintField.length - 1; i >= 0; i--) {
                    const parsed = parseEntry(sprintField[i]);
                    if (parsed) {
                        return parsed;
                    }
                }
                return null;
            }

            return parseEntry(sprintField);
        }

        function createStoryListItem(story) {
            const customField10221 = story.fields.customfield_10221;
            const styles = getStoryStyles(story);
            const sprintFieldValue = story?.fields?.[sprintFieldId] ?? story?.fields?.[SPRINT_FIELD_FALLBACK];
            const sprintName = getLatestSprintName(sprintFieldValue);
            const sprintDisplay = sprintName || 'No Active Sprint';

            console.log(`Rendering story ${story.key} sprint info`, {
                sprintFieldId,
                fallbackField: SPRINT_FIELD_FALLBACK,
                sprintName,
                rawResolvedValue: story?.fields?.[sprintFieldId],
                rawFallbackValue: story?.fields?.[SPRINT_FIELD_FALLBACK]
            });
            
            // Create missing field indicators with same logic as getStoryStyles
            const hasDescription = !isFieldEmpty(story.fields.description, `${story.key}_description`);
            const hasAcceptanceCriteria = !isFieldEmpty(story.fields.customfield_10056, `${story.key}_customfield_10056`);
            const missingFields = [];
            if (!hasDescription) missingFields.push('Description');
            if (!hasAcceptanceCriteria) missingFields.push('Acceptance Criteria');
            
            console.log(`Story ${story.key} - Final missing fields:`, missingFields);
            
            // RESTORED: Show missing field indicators when fields are missing
            const missingFieldsIndicator = missingFields.length > 0 
                ? `<div style="margin-left: 8px; display: flex; align-items: center; gap: 4px;">
                     <i class="fas fa-exclamation-triangle" style="color: #dc2626; font-size: 12px;" title="Missing: ${missingFields.join(', ')}"></i>
                     <span style="color: #dc2626; font-size: 11px; font-weight: 500;" title="Missing: ${missingFields.join(', ')}">Missing: ${missingFields.join(', ')}</span>
                   </div>`
                : '';
            
            return `
                <div class="story-list-item" style="
                    margin-bottom: 8px; 
                    background: ${styles.backgroundColor}; 
                    border: 1px solid ${styles.borderColor}; 
                    border-radius: 6px; 
                    transition: all 0.2s ease;
                " onmouseover="this.style.backgroundColor='${styles.hoverBackgroundColor}'; this.style.borderColor='${styles.hoverBorderColor}';" onmouseout="this.style.backgroundColor='${styles.backgroundColor}'; this.style.borderColor='${styles.borderColor}';">
                    
                    <div style="
                        display: flex; 
                        align-items: center; 
                        padding: 12px 16px; 
                        font-size: 14px;
                    ">
                        <!-- Story Icon and Key -->
                        <div style="display: flex; align-items: center; min-width: 120px; margin-right: 16px;">
                            <i class="fas fa-book" style="color: #3182ce; margin-right: 8px; font-size: 12px;"></i>
                            <span style="font-weight: 600; color: #1f2937; cursor: pointer; text-decoration: underline;" 
                                  onclick="openJiraIssue('${story.key}')" 
                                  onmouseover="this.style.color='#3182ce'" 
                                  onmouseout="this.style.color='#1f2937'"
                                  title="Click to open ${story.key} in JIRA">${story.key}</span>
                            ${missingFieldsIndicator}
                        </div>
                        
                        <!-- Story Title -->
                        <div style="flex: 1; margin-right: 16px;">
                            <span style="color: #374151; line-height: 1.4;">${story.fields.summary}</span>
                        </div>
                        
                        <!-- Status -->
                        <div style="margin-right: 16px; min-width: 100px;">
                            <span style="
                                background: #f0f9ff; 
                                color: #1e40af; 
                                padding: 4px 8px; 
                                border-radius: 4px; 
                                font-size: 12px; 
                                font-weight: 500;
                            ">${story.fields.status.name}</span>
                        </div>
                        
                        <!-- Sprint -->
                        <div style="margin-right: 16px; min-width: 150px; font-size: 13px; color: #1e3a8a; display: flex; align-items: center; gap: 6px;">
                            <i class="fas fa-flag-checkered"></i>
                            <span>${sprintDisplay}</span>
                        </div>

                        <!-- Assignee -->
                        <div style="margin-right: 16px; min-width: 120px; font-size: 13px; color: #6b7280;">
                            <i class="fas fa-user" style="margin-right: 4px;"></i>
                            ${story.fields.assignee ? story.fields.assignee.displayName : 'Unassigned'}
                        </div>
                        
                        <!-- Details Button -->
                        <div>
                            <button class="story-expand-btn" data-story-key="${story.key}" id="btn-${story.key}" style="
                                background: #3182ce; 
                                color: white; 
                                border: none; 
                                padding: 6px 12px; 
                                border-radius: 4px; 
                                font-size: 12px; 
                                cursor: pointer; 
                                transition: all 0.2s ease;
                                display: flex;
                                align-items: center;
                                gap: 4px;
                            " onmouseover="this.style.backgroundColor='#2563eb';" onmouseout="this.style.backgroundColor='#3182ce';">
                                <i class="fas fa-plus"></i>
                                <span>Details</span>
                            </button>
                        </div>
                    </div>
                    
                    <!-- Hidden Details Section -->
                    <div class="story-details" id="details-${story.key}" style="display: none;">
                        <div style="text-align: center; color: #666; padding: 20px;">
                            <i class="fas fa-spinner fa-spin"></i> Loading story details...
                        </div>
                    </div>
                </div>
            `;
        }

        function createStoryCard(story) {
            const customField10221 = story.fields.customfield_10221;
            const sprintFieldValue = story?.fields?.[sprintFieldId] ?? story?.fields?.[SPRINT_FIELD_FALLBACK];
            const sprintName = getLatestSprintName(sprintFieldValue);
            const sprintDisplay = sprintName || 'No Active Sprint';

            console.log(`Rendering detail card sprint info for ${story.key}`, {
                sprintFieldId,
                fallbackField: SPRINT_FIELD_FALLBACK,
                sprintName,
                rawResolvedValue: story?.fields?.[sprintFieldId],
                rawFallbackValue: story?.fields?.[SPRINT_FIELD_FALLBACK]
            });
            
            return `
                <div class="story-card">
                    <div class="story-key">
                        <span style="cursor: pointer; text-decoration: underline; font-weight: 600;" 
                              onclick="openJiraIssue('${story.key}')" 
                              onmouseover="this.style.color='#3182ce'" 
                              onmouseout="this.style.color='inherit'"
                              title="Click to open ${story.key} in JIRA">${story.key}</span>
                        <button class="story-expand-btn" data-story-key="${story.key}" id="btn-${story.key}">
                            <i class="fas fa-plus"></i> Details
                        </button>
                    </div>
                    <div class="story-title">${story.fields.summary}</div>
                    <div class="story-status"><i class="fas fa-info-circle"></i> Status: ${story.fields.status.name}</div>
                    <div class="story-sprint"><i class="fas fa-flag-checkered"></i> Sprint: ${sprintDisplay}</div>
                    <div class="story-assignee"><i class="fas fa-user"></i> Assignee: ${story.fields.assignee ? story.fields.assignee.displayName : 'Unassigned'}</div>
                    ${customField10221 ? `<div class="story-custom-field" style="color: #4a5568; font-size: 0.9rem; margin-top: 8px;"><i class="fas fa-tag"></i> Custom Field: ${customField10221}</div>` : ''}
                    <div class="story-details" id="details-${story.key}">
                        <div style="text-align: center; color: #666; padding: 20px;">
                            <i class="fas fa-spinner fa-spin"></i> Loading story details...
                        </div>
                    </div>
                </div>
            `;
        }

        function toggleFeature(header) {
            const card = header.parentElement;
            const details = card.querySelector('.feature-details');
            const isExpanded = card.classList.contains('expanded');

            if (isExpanded) {
                details.style.display = 'none';
                card.classList.remove('expanded');
            } else {
                details.style.display = 'block';
                card.classList.add('expanded');
            }
        }

        function toggleSection(element, sectionType) {
            event.stopPropagation(); // Prevent triggering parent toggleFeature
            
            const branchItem = element.parentElement;
            const section = branchItem.querySelector(`.${sectionType}-section`);
            const icon = element.querySelector('.section-toggle-icon');
            
            // Add a small delay to make the animation more visible
            icon.style.transform = 'scale(0.9)';
            
            setTimeout(() => {
                if (section.style.display === 'none' || section.style.display === '') {
                    section.style.display = 'block';
                    element.classList.add('section-expanded');
                } else {
                    section.style.display = 'none';
                    element.classList.remove('section-expanded');
                }
                
                // Reset the scale
                icon.style.transform = '';
            }, 100);
        }

        function clearResults() {
            cancelOngoingSearch('Clear button pressed; cancelling active search.');
            resetLoadingState();
            document.getElementById('jqlInput').value = '';
            hideResults();
            hideError();
            showEmptyState();
            searchData = [];
            window.currentSearchData = [];
            window.currentEpicsWithStories = {};
            currentSearchMeta = null;
            window.currentSearchMeta = null;
            lastExecutedJql = '';
        }

        function showLoading(show) {
            document.getElementById('loadingState').style.display = show ? 'block' : 'none';
        }

        function showResults() {
            document.getElementById('searchResults').style.display = 'block';
        }

        function hideResults() {
            document.getElementById('searchResults').style.display = 'none';
        }

        function showEmptyState() {
            document.getElementById('emptyState').style.display = 'block';
        }

        function hideEmptyState() {
            document.getElementById('emptyState').style.display = 'none';
        }

        function showEmptyResults() {
            document.getElementById('resultsContent').innerHTML = `
                <div class="error">
                    <h3><i class="fas fa-search"></i> No Results Found</h3>
                    <p>No Epic (Feature) issues were found for the selected fix version with Team[Team] = 5441.</p>
                    <div style="margin-top: 15px; padding: 15px; background: #f7fafc; border-radius: 8px; border-left: 4px solid #3182ce;">
                        <p style="margin: 0; font-weight: 500;"><i class="fas fa-lightbulb" style="color: #3182ce;"></i> Suggestions:</p>
                        <ul style="margin: 8px 0 0 0; padding-left: 20px;">
                            <li>Try <strong>CT PI26 Sep17-Jan06</strong> (has Epic Features available)</li>
                            <li>Check if the selected fix version has Epic (Feature) issues with Team[Team] = 5441</li>
                            <li>Try removing the Team[Team] filter to see if there are Epics in other teams</li>
                            <li>Use the autocomplete to select from available fix versions</li>
                        </ul>
                    </div>
                </div>
            `;
            showResults();
        }

        function showError(message) {
            document.getElementById('resultsContent').innerHTML = `
                <div class="error">
                    <h3><i class="fas fa-exclamation-triangle"></i> Error</h3>
                    <p>${message}</p>
                </div>
            `;
            showResults();
        }

        function hideError() {
            // Error messages are shown in results content, so clearing results will hide them
        }

        function showDashboardToast(message, variant = 'info') {
            const existingToast = document.getElementById('dashboard-toast');
            if (existingToast) {
                existingToast.remove();
            }

            const palettes = {
                success: { background: '#047857', color: '#ecfdf5' },
                warning: { background: '#b45309', color: '#fffbeb' },
                error: { background: '#b91c1c', color: '#fef2f2' },
                info: { background: '#1d4ed8', color: '#eff6ff' }
            };

            const { background, color } = palettes[variant] || palettes.info;

            const toast = document.createElement('div');
            toast.id = 'dashboard-toast';
            toast.textContent = message;
            toast.style.position = 'fixed';
            toast.style.bottom = '24px';
            toast.style.left = '50%';
            toast.style.transform = 'translateX(-50%)';
            toast.style.background = background;
            toast.style.color = color;
            toast.style.padding = '12px 20px';
            toast.style.borderRadius = '8px';
            toast.style.boxShadow = '0 10px 25px rgba(0, 0, 0, 0.2)';
            toast.style.fontSize = '14px';
            toast.style.fontWeight = '600';
            toast.style.opacity = '0';
            toast.style.transition = 'opacity 0.3s ease';
            toast.style.zIndex = '11000';

            document.body.appendChild(toast);

            requestAnimationFrame(() => {
                toast.style.opacity = '1';
            });

            setTimeout(() => {
                toast.style.opacity = '0';
                setTimeout(() => {
                    toast.remove();
                }, 300);
            }, 4000);
        }

        // Allow Enter key to trigger search
        document.getElementById('jqlInput').addEventListener('keypress', function(e) {
            if (e.key === 'Enter') {
                searchJira();
            }
        });

        // Autocomplete functionality
        let fixVersions = [
            { name: 'CT PI25 Jun25-Sep16', description: 'Planning Increment 25' },
            { name: 'CT PI26 Sep17-Jan06', description: 'Planning Increment 26' },
            { name: 'CT PI27 Jan07-Mar31', description: 'Planning Increment 27' },
            { name: 'CT PI28 Apr01-Jun23', description: 'Planning Increment 28' }
        ];
        let currentHighlight = -1;

        async function loadFixVersions() {
            console.log('loadFixVersions function called');
            try {
                // Try different project keys that might work
                let response;
                try {
                    console.log('Trying to fetch fix versions for project CTLF');
                    response = await fetch('http://localhost:3000/fixversions?project=CTLF');
                } catch (e) {
                    try {
                        console.log('Trying to fetch fix versions for project CTL');
                        response = await fetch('http://localhost:3000/fixversions?project=CTL');
                    } catch (e2) {
                        console.log('Trying to fetch fix versions for project CTL-Fix');
                        response = await fetch('http://localhost:3000/fixversions?project=CTL-Fix');
                    }
                }
                
                const data = await response.json();
                console.log('Fix versions response:', data);
                if (data.error) {
                    console.warn('Fix versions API error:', data.error);
                    // Fallback to common PI versions
                    fixVersions = [
                        { name: 'CT PI25 Jun25-Sep16', description: 'Planning Increment 25' },
                        { name: 'CT PI26 Sep17-Jan06', description: 'Planning Increment 26' },
                        { name: 'CT PI27 Jan07-Mar31', description: 'Planning Increment 27' },
                        { name: 'CT PI28 Apr01-Jun23', description: 'Planning Increment 28' }
                    ];
                } else {
                    fixVersions = data;
                }
                console.log('Loaded fix versions count:', fixVersions.length);
                console.log('Fix versions array:', fixVersions);
            } catch (error) {
                console.error('Error loading fix versions:', error);
                // Fallback versions
                fixVersions = [
                    { name: 'CT PI25 Jun25-Sep16', description: 'Planning Increment 25' },
                    { name: 'CT PI26 Sep17-Jan06', description: 'Planning Increment 26' },
                    { name: 'CT PI27 Jan07-Mar31', description: 'Planning Increment 27' },
                    { name: 'CT PI28 Apr01-Jun23', description: 'Planning Increment 28' }
                ];
                console.log('Using fallback fix versions:', fixVersions);
            }
        }

        function showSuggestions(input, suggestions) {
            console.log('showSuggestions called with:', suggestions.length, 'suggestions');
            const dropdown = document.getElementById('suggestionsDropdown');
            
            if (!dropdown) {
                console.error('Dropdown element not found!');
                return;
            }
            
            if (suggestions.length === 0) {
                console.log('No suggestions to show');
                dropdown.style.display = 'none';
                return;
            }

            // Clear previous content
            dropdown.innerHTML = '';
            
            // Create suggestion elements with proper event listeners
            suggestions.forEach((version, index) => {
                const suggestionDiv = document.createElement('div');
                suggestionDiv.className = 'suggestion-item';
                suggestionDiv.setAttribute('data-index', index);
                
                const mainDiv = document.createElement('div');
                mainDiv.className = 'suggestion-main';
                mainDiv.textContent = version.name;
                suggestionDiv.appendChild(mainDiv);
                
                if (version.description) {
                    const descDiv = document.createElement('div');
                    descDiv.className = 'suggestion-desc';
                    descDiv.textContent = version.description;
                    suggestionDiv.appendChild(descDiv);
                }
                
                // Add click event listener
                suggestionDiv.addEventListener('click', function() {
                    console.log('Suggestion clicked:', version.name);
                    selectSuggestion(version.name);
                });
                
                dropdown.appendChild(suggestionDiv);
            });
            
            dropdown.style.display = 'block';
            currentHighlight = -1;
            console.log('Dropdown shown with', suggestions.length, 'suggestions');
        }

        function hideSuggestions() {
            setTimeout(() => {
                document.getElementById('suggestionsDropdown').style.display = 'none';
            }, 200);
        }

        function selectSuggestion(versionName) {
            console.log('selectSuggestion called with:', versionName);
            const input = document.getElementById('jqlInput');
            const text = input.value;
            
            console.log('Current text:', text);
            
            // Look for fixVersion pattern and replace the value
            const fixVersionRegex = /(fixVersion\s*=\s*)"([^"]*)"/gi;
            
            if (fixVersionRegex.test(text)) {
                // Reset regex for actual replacement
                const newText = text.replace(/(fixVersion\s*=\s*)"([^"]*)"/gi, `$1"${versionName}"`);
                console.log('New text:', newText);
                input.value = newText;
            } else {
                // If no fixVersion found, append to the end
                const newText = text + ` AND fixVersion = "${versionName}"`;
                console.log('Appending new text:', newText);
                input.value = newText;
            }
            
            input.focus();
            document.getElementById('suggestionsDropdown').style.display = 'none';
            console.log('Selection completed, final value:', input.value);
        }

        function filterSuggestions(query) {
            console.log('filterSuggestions called with query:', query);
            console.log('fixVersions array length:', fixVersions.length);
            console.log('fixVersions array:', fixVersions);
            if (!query || query.length < 2) {
                console.log('Query too short, returning empty array');
                return [];
            }
            
            const lowercaseQuery = query.toLowerCase();
            const filtered = fixVersions.filter(version => 
                version.name.toLowerCase().includes(lowercaseQuery)
            ).slice(0, 10);
            console.log('Filtered suggestions:', filtered);
            return filtered;
        }

        function highlightSuggestion(direction) {
            const suggestions = document.querySelectorAll('.suggestion-item');
            if (suggestions.length === 0) return;

            // Remove current highlight
            if (currentHighlight >= 0 && currentHighlight < suggestions.length) {
                suggestions[currentHighlight].classList.remove('highlighted');
            }

            // Update highlight index
            if (direction === 'down') {
                currentHighlight = currentHighlight < suggestions.length - 1 ? currentHighlight + 1 : 0;
            } else if (direction === 'up') {
                currentHighlight = currentHighlight > 0 ? currentHighlight - 1 : suggestions.length - 1;
            }

            // Add new highlight
            if (currentHighlight >= 0 && currentHighlight < suggestions.length) {
                suggestions[currentHighlight].classList.add('highlighted');
                suggestions[currentHighlight].scrollIntoView({ block: 'nearest' });
            }
        }

        function selectHighlightedSuggestion() {
            const highlighted = document.querySelector('.suggestion-item.highlighted');
            if (highlighted) {
                const versionName = highlighted.querySelector('.suggestion-main').textContent;
                selectSuggestion(versionName);
                return true;
            }
            return false;
        }

        // Event listeners for autocomplete
        document.getElementById('jqlInput').addEventListener('input', function(e) {
            console.log('Input event triggered, value:', e.target.value);
            const input = e.target;
            const cursorPos = input.selectionStart;
            const text = input.value;
            const beforeCursor = text.substring(0, cursorPos);
            console.log('Text before cursor:', beforeCursor);
            
            // Check if we're typing after fixVersion =
            const fixVersionMatch = beforeCursor.match(/fixVersion\s*=\s*"?([^"]*?)$/i);
            console.log('Fix version match:', fixVersionMatch);
            
            if (fixVersionMatch) {
                const query = fixVersionMatch[1];
                console.log('Autocomplete query:', query);
                const suggestions = filterSuggestions(query);
                console.log('Filtered suggestions:', suggestions);
                showSuggestions(input, suggestions);
            } else {
                console.log('No fix version match, hiding suggestions');
                hideSuggestions();
            }
        });

        document.getElementById('jqlInput').addEventListener('keydown', function(e) {
            const dropdown = document.getElementById('suggestionsDropdown');
            
            if (dropdown.style.display === 'block') {
                switch(e.key) {
                    case 'ArrowDown':
                        e.preventDefault();
                        highlightSuggestion('down');
                        break;
                    case 'ArrowUp':
                        e.preventDefault();
                        highlightSuggestion('up');
                        break;
                    case 'Enter':
                        if (selectHighlightedSuggestion()) {
                            e.preventDefault();
                        } else {
                            searchJira();
                        }
                        break;
                    case 'Escape':
                        hideSuggestions();
                        break;
                }
            } else if (e.key === 'Enter') {
                searchJira();
            }
        });

        document.getElementById('jqlInput').addEventListener('blur', hideSuggestions);

        async function fetchEpicDetails(epicKey) {
            console.log('fetchEpicDetails called for:', epicKey);
            try {
                // Fetch epic details using individual issue endpoint
                console.log('Making API request to:', `http://localhost:3000/issue/${epicKey}`);
                const response = await fetch(`http://localhost:3000/issue/${epicKey}`);
                console.log('API response status:', response.status);
                
                if (!response.ok) {
                    throw new Error(`HTTP error! status: ${response.status}`);
                }
                
                const epic = await response.json();
                console.log('Received epic data:', epic);
                
                if (epic && epic.fields) {
                    const detailsDiv = document.getElementById(`epic-details-${epicKey}`);
                    
                    // Extract description from rendered fields first, then regular fields
                    let description = null;
                    if (epic.renderedFields && epic.renderedFields.description) {
                        description = epic.renderedFields.description;
                    } else if (epic.fields.description) {
                        description = epic.fields.description;
                    } else {
                        description = 'No description available';
                    }
                    
                    // Try to get acceptance criteria from customfield_10056 for epics too
                    let acceptanceCriteria = null;
                    const acField = 'customfield_10056';
                    
                    // First try rendered fields for best content
                    if (epic.renderedFields && epic.renderedFields[acField]) {
                        console.log(`Found rendered acceptance criteria in ${acField}:`, epic.renderedFields[acField]);
                        acceptanceCriteria = epic.renderedFields[acField];
                    }
                    // Then try regular fields
                    else if (epic.fields && epic.fields[acField]) {
                        console.log(`Found acceptance criteria in ${acField}:`, epic.fields[acField]);
                        acceptanceCriteria = epic.fields[acField];
                    }
                    
                    if (!acceptanceCriteria) {
                        acceptanceCriteria = 'No high level acceptance criteria defined for this feature';
                        console.log(`No acceptance criteria found in ${acField} for epic ${epicKey}`);
                    }
                    
                    // Format description and acceptance criteria
                    const formattedDescription = formatDescription(description, epicKey);
                    const formattedAcceptanceCriteria = formatAcceptanceCriteria(acceptanceCriteria, epicKey);
                    
                    // Display the epic details in a compact format suitable for the Details of Feature section
                    detailsDiv.innerHTML = `
                        <div style="background: white; border: 1px solid #e5e7eb; border-radius: 8px; overflow: hidden;">
                            <!-- Status and Assignee Row -->
                            <div style="display: grid; grid-template-columns: 1fr 1fr; gap: 0;">
                                <!-- Status -->
                                <div style="padding: 15px; border-right: 1px solid #e5e7eb;">
                                    <div style="display: flex; align-items: center; margin-bottom: 8px;">
                                        <i class="fas fa-info-circle" style="color: #3182ce; margin-right: 8px; font-size: 14px;"></i>
                                        <strong style="color: #1f2937; font-size: 14px;">Status</strong>
                                    </div>
                                    <div style="display: flex; align-items: center;">
                                        <span style="background: #f0f9ff; color: #1e40af; padding: 6px 12px; border-radius: 6px; font-weight: 600; font-size: 13px;">
                                            ${epic.fields.status ? epic.fields.status.name : 'Unknown'}
                                        </span>
                                    </div>
                                </div>
                                
                                <!-- Assignee -->
                                <div style="padding: 15px;">
                                    <div style="display: flex; align-items: center; margin-bottom: 8px;">
                                        <i class="fas fa-user" style="color: #8b5cf6; margin-right: 8px; font-size: 14px;"></i>
                                        <strong style="color: #1f2937; font-size: 14px;">Assignee</strong>
                                    </div>
                                    <div style="display: flex; align-items: center;">
                                        ${epic.fields.assignee ? `
                                        <div style="display: flex; align-items: center;">
                                            ${epic.fields.assignee.avatarUrls && epic.fields.assignee.avatarUrls['24x24'] ? `
                                            <img src="${epic.fields.assignee.avatarUrls['24x24']}" alt="${epic.fields.assignee.displayName}" style="width: 24px; height: 24px; border-radius: 50%; margin-right: 8px;">
                                            ` : `
                                            <div style="width: 24px; height: 24px; border-radius: 50%; background: #e5e7eb; display: flex; align-items: center; justify-content: center; margin-right: 8px;">
                                                <i class="fas fa-user" style="color: #6b7280; font-size: 10px;"></i>
                                            </div>
                                            `}
                                            <div>
                                                <div style="font-weight: 600; color: #1f2937; font-size: 13px;">${epic.fields.assignee.displayName}</div>
                                            </div>
                                        </div>
                                        ` : `
                                        <div style="display: flex; align-items: center; justify-content: space-between; width: 100%;">
                                            <div style="display: flex; align-items: center; color: #6b7280;">
                                                <div style="width: 24px; height: 24px; border-radius: 50%; background: #f3f4f6; display: flex; align-items: center; justify-content: center; margin-right: 8px;">
                                                    <i class="fas fa-user-slash" style="color: #9ca3af; font-size: 10px;"></i>
                                                </div>
                                                <span style="font-style: italic; font-size: 13px;">Unassigned</span>
                                            </div>
                                        </div>
                                        `}
                                    </div>
                                </div>
                            </div>
                        </div>
                        
                        <div style="margin-top: 10px; font-size: 11px; color: #9ca3af; text-align: center;">
                            <strong>Epic:</strong> ${epic.key} | <strong>Type:</strong> ${epic.fields.issuetype ? epic.fields.issuetype.name : 'Unknown'}
                        </div>
                    `;
                    
                    // Enhanced debug logging for epic
                    console.log(`Epic ${epicKey} - customfield_10056 analysis:`, {
                        raw_value: epic.fields.customfield_10056,
                        rendered_value: epic.renderedFields?.customfield_10056,
                        raw_type: typeof epic.fields.customfield_10056,
                        rendered_type: typeof epic.renderedFields?.customfield_10056,
                        status: epic.fields.status,
                        assignee: epic.fields.assignee,
                        description: epic.fields.description ? 'Present' : 'Missing'
                    });
                    console.log(`Epic ${epicKey} - Final acceptance criteria selected:`, acceptanceCriteria);
                } else {
                    throw new Error('No epic data received');
                }
            } catch (error) {
                console.error('Error in fetchEpicDetails:', error);
                throw error;
            }
        }

        // Story details functionality - declare at global scope  
        async function toggleStoryDetails(storyKey) {
            console.log('toggleStoryDetails called with storyKey:', storyKey);
            const detailsDiv = document.getElementById(`details-${storyKey}`);
            const button = document.getElementById(`btn-${storyKey}`);
            console.log('Found elements:', { detailsDiv, button });
            
            if (!detailsDiv || !button) {
                console.error('Could not find required elements for story:', storyKey);
                return;
            }
            
            const icon = button.querySelector('i');
            console.log('Current display style:', detailsDiv.style.display);
            
            if (detailsDiv.style.display === 'none' || detailsDiv.style.display === '') {
                // Show details
                console.log('Showing details for story:', storyKey);
                detailsDiv.style.display = 'block';
                icon.classList.remove('fa-plus');
                icon.classList.add('fa-minus');
                button.innerHTML = '<i class="fas fa-minus"></i> Hide';
                
                // Check if we need to fetch the story details
                console.log('Current details content:', detailsDiv.innerHTML);
                if (detailsDiv.innerHTML.includes('Loading story details...')) {
                    console.log('Fetching story details for:', storyKey);
                    try {
                        await fetchStoryDetails(storyKey);
                    } catch (error) {
                        console.error('Error fetching story details:', error);
                        detailsDiv.innerHTML = `
                            <div style="color: #dc2626; padding: 10px;">
                                <i class="fas fa-exclamation-triangle"></i> 
                                Failed to load story details: ${error.message}
                            </div>
                        `;
                    }
                }
            } else {
                // Hide details
                detailsDiv.style.display = 'none';
                icon.classList.remove('fa-minus');
                icon.classList.add('fa-plus');
                button.innerHTML = '<i class="fas fa-plus"></i> Details';
            }
        }

        async function fetchStoryDetails(storyKey) {
            console.log('fetchStoryDetails called for:', storyKey);
            try {
                // Fetch story details using individual issue endpoint
                console.log('Making API request to:', `http://localhost:3000/issue/${storyKey}`);
                const response = await fetch(`http://localhost:3000/issue/${storyKey}`);
                console.log('API response status:', response.status);
                
                if (!response.ok) {
                    throw new Error(`HTTP error! status: ${response.status}`);
                }
                
                const story = await response.json();
                console.log('Received story data:', story);
                
                if (story && story.fields) {
                    const detailsDiv = document.getElementById(`details-${storyKey}`);
                    
                    // Extract description from rendered fields first, then regular fields
                    let description = null;
                    if (story.renderedFields && story.renderedFields.description) {
                        description = story.renderedFields.description;
                    } else if (story.fields.description) {
                        description = story.fields.description;
                    } else {
                        description = 'No description available';
                    }
                    
                    // Use customfield_10056 specifically for High Level Acceptance Criteria
                    let acceptanceCriteria = null;
                    const acField = 'customfield_10056'; // EXACT field for High Level Acceptance Criteria
                    
                    // First try rendered fields for best content
                    if (story.renderedFields && story.renderedFields[acField]) {
                        console.log(`Found rendered acceptance criteria in ${acField}:`, story.renderedFields[acField]);
                        acceptanceCriteria = story.renderedFields[acField];
                    }
                    // Then try regular fields
                    else if (story.fields && story.fields[acField]) {
                        console.log(`Found acceptance criteria in ${acField}:`, story.fields[acField]);
                        acceptanceCriteria = story.fields[acField];
                    }
                    
                    if (!acceptanceCriteria) {
                        acceptanceCriteria = 'No acceptance criteria defined';
                        console.log(`No acceptance criteria found in ${acField} for story ${storyKey}`);
                    }
                    
                    // Format description and acceptance criteria
                    const formattedDescription = formatDescription(description, storyKey);
                    const formattedAcceptanceCriteria = formatAcceptanceCriteria(acceptanceCriteria, storyKey);
                    
                    // Display the details
                    detailsDiv.innerHTML = `
                        <div style="margin-bottom: 15px;">
                            <h4 style="margin: 0 0 8px 0; color: #1f2937; font-size: 14px;">
                                <i class="fas fa-file-alt" style="color: #f59e0b; margin-right: 6px;"></i>
                                Description
                            </h4>
                            <div style="background: white; padding: 10px; border-radius: 6px; font-size: 13px; line-height: 1.5; color: #4b5563;">
                                ${formattedDescription.content}
                            </div>
                        </div>
                        
                        <div>
                            <h4 style="margin: 0 0 8px 0; color: #1f2937; font-size: 14px;">
                                <i class="fas fa-check-circle" style="color: #22c55e; margin-right: 6px;"></i>
                                High Level Acceptance Criteria
                            </h4>
                            <div style="background: white; padding: 10px; border-radius: 6px; font-size: 13px; line-height: 1.5; color: #4b5563;">
                                ${formattedAcceptanceCriteria.content}
                            </div>
                        </div>
                        
                        <div style="margin-top: 10px; padding-top: 10px; border-top: 1px solid #e5e7eb; font-size: 12px; color: #6b7280;">
                            <strong>Status:</strong> ${story.fields.status ? story.fields.status.name : 'Unknown'} | 
                            <strong>Assignee:</strong> ${story.fields.assignee ? story.fields.assignee.displayName : 'Unassigned'} |
                            <strong>Issue Type:</strong> ${story.fields.issuetype ? story.fields.issuetype.name : 'Unknown'}
                        </div>
                        
                        <div style="margin-top: 8px; font-size: 11px; color: #9ca3af;">
                            <strong>Debug:</strong> Check console for field details
                        </div>
                    `;
                    
                    // Enhanced debug logging for customfield_10056
                    console.log(`Story ${storyKey} - customfield_10056 analysis:`, {
                        raw_value: story.fields.customfield_10056,
                        rendered_value: story.renderedFields?.customfield_10056,
                        raw_type: typeof story.fields.customfield_10056,
                        rendered_type: typeof story.renderedFields?.customfield_10056,
                        raw_keys: story.fields.customfield_10056 && typeof story.fields.customfield_10056 === 'object' ? Object.keys(story.fields.customfield_10056) : 'not an object',
                        rendered_keys: story.renderedFields?.customfield_10056 && typeof story.renderedFields.customfield_10056 === 'object' ? Object.keys(story.renderedFields.customfield_10056) : 'not an object'
                    });
                    console.log(`Story ${storyKey} - Final acceptance criteria selected:`, acceptanceCriteria);
                } else {
                    throw new Error('No story data received');
                }
            } catch (error) {
                console.error('Error in fetchStoryDetails:', error);
                throw error;
            }
        }

        function formatDescription(description, issueKey) {
            if (!description || description === 'No description available') {
                return {
                    content: `<em style="color: #9ca3af;">No description provided for this story.</em>`,
                    isEmpty: true,
                    issueKey: issueKey
                };
            }
            
            // Handle JIRA ADF format or plain text
            let formattedContent = '';
            if (typeof description === 'object' && description !== null) {
                if (description.content) {
                    // JIRA Atlassian Document Format
                    formattedContent = extractTextFromADF(description);
                } else {
                    // Try to extract any meaningful content
                    formattedContent = `<pre style="background: #f3f4f6; padding: 8px; border-radius: 4px;">${JSON.stringify(description, null, 2)}</pre>`;
                }
            } else if (typeof description === 'string') {
                // Plain text with basic formatting
                formattedContent = description.replace(/\n/g, '<br>');
                formattedContent = formattedContent.replace(/\*([^*]+)\*/g, '<strong>$1</strong>');
                formattedContent = formattedContent.replace(/_([^_]+)_/g, '<em>$1</em>');
            } else {
                formattedContent = String(description);
            }
            
            return {
                content: formattedContent,
                isEmpty: false,
                issueKey: issueKey
            };
        }

        function formatAcceptanceCriteria(criteria, issueKey) {
            console.log('formatAcceptanceCriteria called with:', criteria);
            console.log('Type:', typeof criteria);
            console.log('Full object structure:', JSON.stringify(criteria, null, 2));
            
            if (!criteria || criteria === 'No acceptance criteria defined' || criteria === 'No high level acceptance criteria defined for this feature') {
                return {
                    content: `<em style="color: #9ca3af;">No high level acceptance criteria defined for this story.</em>`,
                    isEmpty: true,
                    issueKey: issueKey
                };
            }
            
            // If it's already HTML (from rendered fields), use it directly
            if (typeof criteria === 'string' && (criteria.includes('<') || criteria.length > 10)) {
                console.log('Using HTML rendered content or long string');
                let formatted = criteria.replace(/\n/g, '<br>');
                formatted = formatted.replace(/\*([^*]+)\*/g, '<strong>$1</strong>');
                
                // Format as bullet points if not already formatted
                if (!formatted.includes('•') && !formatted.includes('<li>') && !formatted.includes('*') && !formatted.includes('-')) {
                    const lines = formatted.split('<br>').filter(line => line.trim());
                    if (lines.length > 1) {
                        formatted = lines.map(line => `• ${line.trim()}`).join('<br>');
                    }
                }
                return {
                    content: formatted,
                    isEmpty: false,
                    issueKey: issueKey
                };
            }
            
            // Handle string content
            if (typeof criteria === 'string') {
                console.log('Processing string criteria');
                let formatted = criteria.replace(/\n/g, '<br>');
                formatted = formatted.replace(/\*([^*]+)\*/g, '<strong>$1</strong>');
                return {
                    content: formatted,
                    isEmpty: false,
                    issueKey: issueKey
                };
            }
            
            // Handle array content
            if (Array.isArray(criteria)) {
                console.log('Processing array of criteria');
                const content = criteria.map(item => {
                    if (typeof item === 'string') {
                        return `• ${item}`;
                    } else if (typeof item === 'object' && item !== null) {
                        return `• ${extractTextFromObject(item)}`;
                    }
                    return `• ${String(item)}`;
                }).join('<br>');
                return {
                    content: content,
                    isEmpty: false,
                    issueKey: issueKey
                };
            }
            
            // Handle object content - Enhanced for customfield_10056
            if (typeof criteria === 'object' && criteria !== null) {
                console.log('Processing object criteria. Keys:', Object.keys(criteria));
                console.log('Detailed object analysis:', criteria);
                
                // Handle JIRA Atlassian Document Format (ADF)
                if (criteria.content) {
                    console.log('Found ADF content structure');
                    const content = extractTextFromADF(criteria);
                    return {
                        content: content,
                        isEmpty: false,
                        issueKey: issueKey
                    };
                }
                
                // Enhanced text extraction for customfield_10056 objects
                const textExtractionResult = extractTextFromCustomField10056(criteria);
                if (textExtractionResult && textExtractionResult !== 'No content found') {
                    console.log('Successfully extracted text from customfield_10056:', textExtractionResult);
                    return {
                        content: textExtractionResult,
                        isEmpty: false,
                        issueKey: issueKey
                    };
                }
                
                // Fallback: Show detailed object info for debugging
                return {
                    content: `<div style="background: #fef3c7; padding: 12px; border-radius: 6px; border-left: 4px solid #f59e0b;">
                        <strong>⚠ customfield_10056 Object Analysis:</strong><br>
                        <div style="margin-top: 8px;">
                            <strong>Object Type:</strong> ${Array.isArray(criteria) ? 'Array' : 'Object'}<br>
                            <strong>Properties:</strong> ${Object.keys(criteria).join(', ')}<br>
                            ${criteria.id ? `<strong>ID:</strong> ${criteria.id}<br>` : ''}
                            ${criteria.value ? `<strong>Value:</strong> ${criteria.value}<br>` : ''}
                            ${criteria.name ? `<strong>Name:</strong> ${criteria.name}<br>` : ''}
                            ${criteria.displayName ? `<strong>Display Name:</strong> ${criteria.displayName}<br>` : ''}
                        </div>
                        <details style="margin-top: 10px;">
                            <summary style="cursor: pointer; color: #92400e; font-weight: 500;">Show Complete Object Structure</summary>
                            <pre style="background: #f9fafb; padding: 10px; border-radius: 4px; margin-top: 6px; font-size: 11px; max-height: 300px; overflow-y: auto; border: 1px solid #e5e7eb;">${JSON.stringify(criteria, null, 2)}</pre>
                        </details>
                    </div>`,
                    isEmpty: false,
                    issueKey: issueKey
                };
            }
            
            console.log('Fallback: converting to string');
            return {
                content: String(criteria),
                isEmpty: false,
                issueKey: issueKey
            };
        }

        function extractTextFromCustomField10056(obj) {
            console.log('extractTextFromCustomField10056 called with:', obj);
            
            if (!obj || typeof obj !== 'object') {
                return String(obj || '');
            }
            
            // Priority order for text extraction from customfield_10056
            const textProperties = [
                'value',          // Most common for select/text fields
                'name',           // For option objects
                'displayName',    // For user/option objects  
                'text',           // For text content
                'summary',        // For summary content
                'description',    // For description content
                'content'         // For rich text content
            ];
            
            // Check direct properties first
            for (const prop of textProperties) {
                if (obj[prop] !== undefined && obj[prop] !== null) {
                    const value = obj[prop];
                    console.log(`Found property ${prop} with value:`, value, 'type:', typeof value);
                    
                    if (typeof value === 'string' && value.trim().length > 0) {
                        const content = value.trim();
                        console.log(`Extracted text from ${prop}:`, content);
                        
                        // Format as bullet points if multiple lines
                        const lines = content.split('\n').filter(line => line.trim());
                        if (lines.length > 1) {
                            return lines.map(line => `• ${line.trim()}`).join('<br>');
                        }
                        return content;
                    }
                    
                    // Handle nested objects
                    if (typeof value === 'object' && value !== null) {
                        console.log(`Found nested object in ${prop}, recursing...`);
                        const nestedResult = extractTextFromCustomField10056(value);
                        if (nestedResult && nestedResult !== 'No content found') {
                            return nestedResult;
                        }
                    }
                }
            }
            
            // Check for array content
            if (Array.isArray(obj)) {
                console.log('Processing array content');
                const textItems = [];
                for (const item of obj) {
                    if (typeof item === 'string' && item.trim().length > 0) {
                        textItems.push(item.trim());
                    } else if (typeof item === 'object' && item !== null) {
                        const itemText = extractTextFromCustomField10056(item);
                        if (itemText && itemText !== 'No content found') {
                            textItems.push(itemText);
                        }
                    }
                }
                if (textItems.length > 0) {
                    return textItems.map(item => `• ${item}`).join('<br>');
                }
            }
            
            // Check nested common structures for JIRA objects
            const nestedPaths = [
                ['child', 'value'],
                ['option', 'value'], 
                ['option', 'name'],
                ['user', 'displayName'],
                ['project', 'name'],
                ['issuetype', 'name'],
                ['status', 'name'],
                ['priority', 'name'],
                ['resolution', 'name'],
                ['content', 'text'],
                ['content', 'value']
            ];
            
            for (const path of nestedPaths) {
                let current = obj;
                let pathFound = true;
                
                for (const segment of path) {
                    if (current && typeof current === 'object' && current[segment] !== undefined) {
                        current = current[segment];
                    } else {
                        pathFound = false;
                        break;
                    }
                }
                
                if (pathFound && typeof current === 'string' && current.trim().length > 0) {
                    console.log(`Found text at path ${path.join('.')}:`, current);
                    const content = current.trim();
                    const lines = content.split('\n').filter(line => line.trim());
                    if (lines.length > 1) {
                        return lines.map(line => `• ${line.trim()}`).join('<br>');
                    }
                    return content;
                }
            }
            
            // Special handling for JIRA Atlassian Document Format
            if (obj.content && Array.isArray(obj.content)) {
                console.log('Attempting ADF extraction...');
                const adfResult = extractTextFromADF(obj);
                if (adfResult !== 'Content format not fully supported') {
                    return adfResult;
                }
            }
            
            // Deep search for any text content in the object
            console.log('Performing deep text search...');
            const allKeys = Object.keys(obj);
            for (const key of allKeys) {
                if (typeof obj[key] === 'string' && obj[key].trim().length > 3) {
                    // Skip obvious non-content keys
                    if (!['id', 'self', 'key', 'url', 'avatar'].includes(key.toLowerCase())) {
                        console.log(`Found potential text content in ${key}:`, obj[key]);
                        const content = obj[key].trim();
                        const lines = content.split('\n').filter(line => line.trim());
                        if (lines.length > 1) {
                            return lines.map(line => `• ${line.trim()}`).join('<br>');
                        }
                        return content;
                    }
                }
            }
            
            console.log('No text content found in customfield_10056 object');
            return 'No content found';
        }

        function extractTextFromObject(obj) {
            if (!obj || typeof obj !== 'object') {
                return String(obj || '');
            }
            
            // Check common text properties
            const textProps = ['value', 'displayName', 'name', 'text', 'summary', 'description', 'content'];
            for (const prop of textProps) {
                if (obj[prop] && typeof obj[prop] === 'string' && obj[prop].trim().length > 0) {
                    const content = String(obj[prop]);
                    const lines = content.split('\n').filter(line => line.trim());
                    if (lines.length > 1) {
                        return lines.map(line => `• ${line.trim()}`).join('<br>');
                    }
                    return content;
                }
            }
            
            // Check for nested objects
            for (const key of Object.keys(obj)) {
                if (typeof obj[key] === 'object' && obj[key] !== null) {
                    const nestedResult = extractTextFromObject(obj[key]);
                    if (nestedResult && nestedResult !== 'No content found') {
                        return nestedResult;
                    }
                }
            }
            
            return 'No content found';
        }

        function extractTextFromADF(adfContent) {
            // Basic ADF (Atlassian Document Format) text extraction
            if (!adfContent || typeof adfContent !== 'object') {
                return String(adfContent || 'No content');
            }
            
            if (adfContent.content && Array.isArray(adfContent.content)) {
                return adfContent.content.map(node => {
                    return extractNodeText(node);
                }).filter(text => text.trim()).join('<br><br>');
            }
            
            return 'Content format not fully supported';
        }

        function extractNodeText(node) {
            if (!node || typeof node !== 'object') {
                return String(node || '');
            }
            
            switch (node.type) {
                case 'paragraph':
                    if (node.content && Array.isArray(node.content)) {
                        return node.content.map(textNode => {
                            if (textNode.type === 'text') {
                                return textNode.text || '';
                            }
                            return '';
                        }).join('');
                    }
                    break;
                case 'text':
                    return node.text || '';
                case 'bulletList':
                case 'orderedList':
                    if (node.content && Array.isArray(node.content)) {
                        return node.content.map(listItem => {
                            return `• ${extractNodeText(listItem)}`;
                        }).join('<br>');
                    }
                    break;
                case 'listItem':
                    if (node.content && Array.isArray(node.content)) {
                        return node.content.map(item => extractNodeText(item)).join(' ');
                    }
                    break;
                default:
                    if (node.content && Array.isArray(node.content)) {
                        return node.content.map(child => extractNodeText(child)).join(' ');
                    }
                    return String(node.text || '');
            }
            
            return '';
        }

        // Direct Email Functionality (No Preview)
        async function sendEmailsDirectly(epicKey) {
            console.log('=== INDIVIDUAL STORY EMAIL SEND START ===');
            console.log('Epic Key:', epicKey);
            
            await ensureEpicStoriesCached(epicKey);
            const epicStories = getStoriesForEmailEpic(epicKey);
            console.log('Total Stories Found:', epicStories.length);
            
            if (epicStories.length === 0) {
                alert('No stories found for this feature.');
                return;
            }
            
            const storiesWithMissingFields = findStoriesWithMissingFields(epicStories);
            console.log('Stories with missing fields:', storiesWithMissingFields.length);
            
            if (storiesWithMissingFields.length === 0) {
                alert('Great! All stories in this feature have complete description and acceptance criteria.');
                return;
            }

            // Send email notifications for each story
            sendIndividualStoryEmails(storiesWithMissingFields, epicKey);
        }

        async function ensureEpicStoriesCached(epicKey) {
            if (!window.currentEpicsWithStories) {
                window.currentEpicsWithStories = {};
            }

            const cachedStories = window.currentEpicsWithStories[epicKey];
            if (Array.isArray(cachedStories) && cachedStories.length > 0) {
                return cachedStories;
            }

            try {
                console.log(`Cache miss for ${epicKey}, fetching stories on demand.`);
                const freshStories = await getStoriesForEpic(epicKey);
                if (Array.isArray(freshStories) && freshStories.length > 0) {
                    window.currentEpicsWithStories[epicKey] = freshStories;
                }
                return freshStories || [];
            } catch (error) {
                console.error(`Failed to fetch stories for ${epicKey} during email prep:`, error);
                return cachedStories || [];
            }
        }

        function sendIndividualStoryEmails(stories, epicKey) {
            console.log('=== SENDING EMAIL NOTIFICATIONS ===');
            console.log('Stories to process:', stories.length);
            
            let emailsData = [];
            
            stories.forEach((story, index) => {
                console.log(`\n--- Processing Story ${index + 1}: ${story.key} ---`);
                
                // Get reporter email for TO field
                let reporterEmail = null;
                let reporterName = 'Reporter';
                
                if (story.fields.reporter) {
                    reporterEmail = story.fields.reporter.emailAddress || 
                                  story.fields.reporter.email || 
                                  story.fields.reporter.name;
                    reporterName = story.fields.reporter.displayName || 
                                  story.fields.reporter.name || 
                                  'Reporter';
                }
                
                console.log('Story reporter email:', reporterEmail);
                console.log('Story reporter name:', reporterName);
                
                // Get assignee email for TO field (now primary recipient)
                let assigneeEmail = null;
                let assigneeName = 'Unassigned';
                
                if (story.fields.assignee) {
                    assigneeEmail = story.fields.assignee.emailAddress || 
                                   story.fields.assignee.email || 
                                   story.fields.assignee.name;
                    assigneeName = story.fields.assignee.displayName || 
                                  story.fields.assignee.name || 
                                  'Assigned User';
                }
                
                console.log('Story assignee email:', assigneeEmail);
                console.log('Story assignee name:', assigneeName);
                
                // Determine primary recipient (assignee preferred, fallback to reporter if no assignee)
                const toEmail = assigneeEmail || reporterEmail;
                if (!toEmail) {
                    console.log(`⚠️ Skipping story ${story.key} - no available recipient (assignee/reporter)`);
                    return;
                }

                // Prepare individual email for this specific story (greet primary recipient)
                const emailTemplate = generateIndividualStoryEmailTemplate(
                    assigneeName || reporterName,
                    story,
                    reporterName,
                    epicKey
                );

                const subject = encodeURIComponent(emailTemplate.subject);
                const body = encodeURIComponent(emailTemplate.body);
                const ccParam = reporterEmail && reporterEmail !== toEmail ?
                               `&cc=${encodeURIComponent(reporterEmail)}` : '';
                const mailtoLink = `mailto:${toEmail}?subject=${subject}&body=${body}${ccParam}`;
                
                emailsData.push({
                    story: story.key,
                    storyTitle: story.fields.summary,
                    to: toEmail,
                    cc: reporterEmail || 'none',
                    reporterName: reporterName,
                    assigneeName: assigneeName,
                    reporterEmail: reporterEmail,
                    assigneeEmail: assigneeEmail,
                    subject: emailTemplate.subject,
                    body: emailTemplate.body,
                    mailtoLink: mailtoLink
                });
            });

            if (emailsData.length === 0) {
                alert('No valid email addresses found for stories with missing fields.');
                return;
            }

            // Show interactive email modal to avoid popup blocking
            showIndividualEmailModal(emailsData, epicKey);
        }

        function showIndividualEmailModal(emailsData, epicKey) {
            const modal = document.createElement('div');
            modal.style.cssText = `
                position: fixed; top: 0; left: 0; width: 100%; height: 100%; 
                background: rgba(0,0,0,0.8); z-index: 10000; display: flex; 
                align-items: center; justify-content: center; padding: 20px;
            `;
            
            const modalContent = document.createElement('div');
            modalContent.style.cssText = `
                background: white; border-radius: 12px; padding: 30px; 
                max-width: 900px; width: 100%; max-height: 85vh; overflow-y: auto;
                box-shadow: 0 15px 40px rgba(0,0,0,0.4);
            `;
            
            modalContent.innerHTML = `
                <div style="display: flex; justify-content: space-between; align-items: center; margin-bottom: 25px; border-bottom: 3px solid #4299e1; padding-bottom: 15px;">
                    <h2 style="margin: 0; color: #2d3748; font-size: 26px;">📧 Email Notification</h2>
                    <button onclick="this.closest('[style*=position]').remove()" style="background: none; border: none; font-size: 28px; cursor: pointer; color: #666; hover: color: #000;">&times;</button>
                </div>
                
                <div style="margin-bottom: 25px; padding: 20px; background: linear-gradient(135deg, #667eea 0%, #764ba2 100%); border-radius: 10px; color: white;">
                    <h3 style="margin: 0 0 10px 0; font-size: 18px;">🎯 Feature: ${epicKey}</h3>
                    <p style="margin: 0; font-size: 14px; opacity: 0.9;">${emailsData.length} emails will be sent - each to the story assignee (TO) with reporter (CC).</p>
                </div>
                
                <div style="margin-bottom: 25px; text-align: center;">
                    <button onclick="previewEmails()" style="background: linear-gradient(135deg, #4299e1 0%, #3182ce 100%); color: white; border: none; padding: 15px 30px; border-radius: 10px; cursor: pointer; font-size: 16px; font-weight: bold; box-shadow: 0 6px 20px rgba(66, 153, 225, 0.4); transition: all 0.3s ease; margin-right: 15px;"
                            onmouseover="this.style.transform='translateY(-3px)'; this.style.boxShadow='0 8px 25px rgba(66, 153, 225, 0.5)';"
                            onmouseout="this.style.transform='translateY(0)'; this.style.boxShadow='0 6px 20px rgba(66, 153, 225, 0.4)';">
                        Preview First Email
                    </button>
                    <button onclick="sendAllIndividualEmails()" style="background: linear-gradient(135deg, #48bb78 0%, #38a169 100%); color: white; border: none; padding: 15px 30px; border-radius: 10px; cursor: pointer; font-size: 16px; font-weight: bold; box-shadow: 0 6px 20px rgba(72, 187, 120, 0.4); transition: all 0.3s ease;"
                            onmouseover="this.style.transform='translateY(-3px)'; this.style.boxShadow='0 8px 25px rgba(72, 187, 120, 0.5)';"
                            onmouseout="this.style.transform='translateY(0)'; this.style.boxShadow='0 6px 20px rgba(72, 187, 120, 0.4)';">
                        � Send All Emails (${emailsData.length} total)
                    </button>
                </div>
                
                <div id="emailList" style="gap: 15px; display: flex; flex-direction: column;">
                    ${emailsData.map((email, index) => `
                        <div style="border: 2px solid #e2e8f0; border-radius: 12px; padding: 20px; background: linear-gradient(135deg, #f8f9fa 0%, #e9ecef 100%); box-shadow: 0 4px 8px rgba(0,0,0,0.1);">
                            <div style="display: flex; justify-content: space-between; align-items: flex-start;">
                                <div style="flex: 1;">
                                    <h4 style="margin: 0 0 8px 0; color: #2d3748; font-size: 18px; font-weight: bold;">📝 Email ${index + 1}: ${email.story}</h4>
                                    <p style="margin: 0 0 10px 0; color: #4a5568; font-size: 14px; font-style: italic; line-height: 1.4;">${email.storyTitle}</p>
                                    <div style="font-size: 13px; color: #666; line-height: 1.6;">
                                        <p style="margin: 3px 0;"><strong style="color: #2d3748;">📤 TO:</strong> ${email.assigneeName} <span style="color: #4a5568;">(${email.to})</span></p>
                                        <p style="margin: 3px 0;"><strong style="color: #2d3748;">📬 CC:</strong> ${email.reporterName} <span style="color: #4a5568;">(${email.cc})</span></p>
                                    </div>
                                </div>
                                <div style="background: #e8f5e8; padding: 8px 12px; border-radius: 6px; font-size: 12px; color: #2d5016; font-weight: bold;">
                                    Will be sent
                                </div>
                            </div>
                        </div>
                    `).join('')}
                </div>
                
                <div style="margin-top: 25px; padding: 20px; background: #f0f9ff; border: 2px solid #bfdbfe; border-radius: 10px; text-align: center;">
                    <p style="margin: 0; color: #1e40af; font-size: 14px; line-height: 1.5;"><strong>💡 Tip:</strong> Click "Send All Emails" button above to open all ${emailsData.length} emails at once. Each email will open with a short delay to ensure all emails are sent successfully.</p>
                </div>
            `;
            
            modal.appendChild(modalContent);
            document.body.appendChild(modal);
            
            // Store email data globally for functions
            window.currentEmailsData = emailsData;
            
            // Add global function to preview the first email
            window.previewEmails = function() {
                if (emailsData.length === 0) {
                    alert('No emails to preview!');
                    return;
                }
                
                const firstEmail = emailsData[0];
                
                // Create preview modal
                const modal = document.createElement('div');
                modal.style.cssText = `
                    position: fixed;
                    top: 0;
                    left: 0;
                    width: 100%;
                    height: 100%;
                    background: rgba(0,0,0,0.8);
                    z-index: 10000;
                    display: flex;
                    align-items: center;
                    justify-content: center;
                    font-family: Arial, sans-serif;
                `;
                
                modal.innerHTML = `
                    <div style="background: white; border-radius: 15px; max-width: 800px; max-height: 90vh; overflow-y: auto; margin: 20px; box-shadow: 0 20px 60px rgba(0,0,0,0.3);">
                        <div style="padding: 30px; border-bottom: 2px solid #e2e8f0;">
                            <h2 style="margin: 0 0 15px 0; color: #2d3748; display: flex; align-items: center;">
                                <span style="margin-right: 10px;">📧</span> Email Preview
                            </h2>
                            <p style="margin: 0; color: #718096; font-size: 14px;">Preview of the email that will be sent to story reporters</p>
                        </div>
                        
                        <div style="padding: 30px;">
                            <div style="margin-bottom: 25px; padding: 20px; background: #f7fafc; border-radius: 10px; border-left: 4px solid #4299e1;">
                                <h3 style="margin: 0 0 10px 0; color: #2d3748; font-size: 16px;">Email Details</h3>
                                <div style="font-size: 14px; line-height: 1.6;">
                                    <strong>TO:</strong> ${firstEmail.assigneeName} (${firstEmail.assigneeEmail || firstEmail.to})<br>
                                    <strong>CC:</strong> ${firstEmail.reporterName} (${firstEmail.reporterEmail || firstEmail.cc})<br>
                                    <strong>SUBJECT:</strong> ${firstEmail.subject}
                                </div>
                            </div>
                            
                            <div style="margin-bottom: 25px;">
                                <h3 style="margin: 0 0 15px 0; color: #2d3748; font-size: 16px;">Email Body</h3>
                                <div style="background: #f8f9fa; border: 1px solid #e2e8f0; border-radius: 8px; padding: 20px; font-family: monospace; font-size: 13px; line-height: 1.6; white-space: pre-wrap; max-height: 400px; overflow-y: auto;">${firstEmail.body}</div>
                            </div>
                            
                            <div style="text-align: center; border-top: 2px solid #e2e8f0; padding-top: 25px;">
                                <button onclick="this.parentElement.parentElement.parentElement.parentElement.remove()" style="background: #e2e8f0; color: #4a5568; border: none; padding: 12px 25px; border-radius: 8px; cursor: pointer; margin-right: 15px; font-size: 14px; font-weight: bold;">Close Preview</button>
                                <button onclick="this.parentElement.parentElement.parentElement.parentElement.remove(); sendAllIndividualEmails();" style="background: linear-gradient(135deg, #48bb78 0%, #38a169 100%); color: white; border: none; padding: 12px 25px; border-radius: 8px; cursor: pointer; font-size: 14px; font-weight: bold;">Send All ${emailsData.length} Emails</button>
                            </div>
                        </div>
                    </div>
                `;
                
                // Close modal when clicking outside
                modal.addEventListener('click', function(e) {
                    if (e.target === modal) {
                        modal.remove();
                    }
                });
                
                document.body.appendChild(modal);
            };
            
            // Add global function to send all emails automatically with timing delays
            window.sendAllIndividualEmails = async function() {
                console.log(`🚀 Automatically sending all ${emailsData.length} email notifications...`);
                
                const totalEmails = emailsData.length;
                let currentIndex = 0;
                let successCount = 0;
                let failureCount = 0;
                let retryQueue = [];
                
                // Create enhanced progress modal
                const progressModal = document.createElement('div');
                progressModal.style.cssText = `
                    position: fixed;
                    top: 0;
                    left: 0;
                    width: 100%;
                    height: 100%;
                    background: rgba(0,0,0,0.9);
                    z-index: 10001;
                    display: flex;
                    align-items: center;
                    justify-content: center;
                `;
                
                const progressContent = document.createElement('div');
                progressContent.style.cssText = `
                    background: white;
                    padding: 40px;
                    border-radius: 15px;
                    text-align: center;
                    max-width: 700px;
                    width: 95%;
                    box-shadow: 0 15px 40px rgba(0,0,0,0.4);
                    max-height: 90vh;
                    overflow-y: auto;
                `;
                
                progressModal.appendChild(progressContent);
                document.body.appendChild(progressModal);
                
                // Batch processing confirmation - 3 emails per click
                const confirmed = confirm(`� Individual Email Confirmation\n\nThis will automatically send ${totalEmails} individual emails directly through Microsoft Outlook.\n\nEach email will be:\n• Sent to Story Assignee\n• CC: Story Reporter (if different)\n• Saved in your Outlook Sent Items\n• Subject: Missing required field - [Story] - Action Required\n\nContinue with direct email sending?`);

                if (!confirmed) {
                    progressModal.remove();
                    return;
                }

                // Provide immediate visual feedback while the server processes the request
                progressContent.innerHTML = `
                    <div style="display: flex; flex-direction: column; align-items: center; gap: 16px;">
                        <div class="spinner" style="width: 40px; height: 40px; border: 4px solid #bfdbfe; border-top: 4px solid #4299e1; border-radius: 50%; animation: spin 1s linear infinite;"></div>
                        <div style="font-size: 16px; color: #1e3a8a; font-weight: 600;">Sending ${totalEmails} Outlook email${totalEmails === 1 ? '' : 's'}...</div>
                        <div style="font-size: 13px; color: #475569;">This may take a few moments while Outlook processes each notification.</div>
                    </div>
                    <style>
                        @keyframes spin {
                            0% { transform: rotate(0deg); }
                            100% { transform: rotate(360deg); }
                        }
                    </style>
                `;

                // Send emails via server-side Outlook automation

                
                try {
                    console.log('📧 Sending email request to server...');
                    
                    const response = await fetch('http://localhost:3000/send-emails', {
                        method: 'POST',
                        headers: {
                            'Content-Type': 'application/json'
                        },
                        body: JSON.stringify({
                            emailsData: emailsData
                        })
                    });
                    
                    if (!response.ok) {
                        throw new Error(`Server responded with status ${response.status}`);
                    }

                    const result = await response.json();
                    
                    if (result.success) {
                        successCount = result.result?.success || 0;
                        failureCount = result.result?.failure || 0;

                        console.log('✅ Server-side email sending completed');
                        console.log(`📊 Results: ${successCount} successful, ${failureCount} failed`);

                        const toastVariant = failureCount > 0 ? 'warning' : 'success';
                        const toastMessage = failureCount > 0
                            ? `Email notifications sent. Success: ${successCount}, Failed: ${failureCount}.`
                            : `Email notifications sent to ${successCount} assignees.`;

                        closeEmailModal();
                        showDashboardToast(toastMessage, toastVariant);
                        return;
                    } else {
                        throw new Error(result.details || 'Email sending failed');
                    }
                    
                } catch (error) {
                    console.error('❌ Failed to send emails via server:', error);
                    if (progressModal && progressModal.parentNode) {
                        progressModal.remove();
                    }
                    showDashboardToast(`Email notifications failed: ${error.message}`, 'error');
                    return;
                }
                    
                
                // Batch processing function
                function processNextBatch() {
                    const progress = Math.round((currentIndex / totalEmails) * 100);
                    
                    if (currentIndex >= totalEmails) {
                        showCompletionStatus();
                        return;
                    }
                    
                    const currentBatch = emailsData.slice(currentIndex, Math.min(currentIndex + BATCH_SIZE, totalEmails));
                    const batchNumber = batchesProcessed + 1;
                    
                    // Show batch ready for processing
                    progressContent.innerHTML = `
                        <h3 style="color: #4299e1; margin-bottom: 25px;">📧 Batch Processing - Auto-Open 3 Emails</h3>
                        
                        <div style="display: grid; grid-template-columns: repeat(auto-fit, minmax(120px, 1fr)); gap: 15px; margin-bottom: 25px;">
                            <div style="background: #e6f3ff; padding: 15px; border-radius: 8px; text-center;">
                                <div style="font-size: 20px; font-weight: bold; color: #2563eb;">${batchNumber}</div>
                                <div style="font-size: 12px; color: #666;">Current Batch</div>
                            </div>
                            <div style="background: #f0f9f0; padding: 15px; border-radius: 8px; text-center;">
                                <div style="font-size: 20px; font-weight: bold; color: #059669;">${successCount}</div>
                                <div style="font-size: 12px; color: #666;">Opened</div>
                            </div>
                            <div style="background: #fef2f2; padding: 15px; border-radius: 8px; text-center;">
                                <div style="font-size: 20px; font-weight: bold; color: #dc2626;">${failureCount}</div>
                                <div style="font-size: 12px; color: #666;">Failed</div>
                            </div>
                            <div style="background: #fef3c7; padding: 15px; border-radius: 8px; text-center;">
                                <div style="font-size: 20px; font-weight: bold; color: #d97706;">${totalBatches}</div>
                                <div style="font-size: 12px; color: #666;">Total Batches</div>
                            </div>
                        </div>
                        
                        <div style="background: #e2e8f0; border-radius: 15px; height: 20px; margin-bottom: 25px; overflow: hidden;">
                            <div style="background: linear-gradient(90deg, #4299e1, #48bb78); height: 100%; width: ${progress}%; transition: width 0.5s ease;"></div>
                        </div>
                        
                        <div style="background: #f7fafc; border: 2px solid #e2e8f0; border-radius: 12px; padding: 20px; margin-bottom: 25px; text-align: left;">
                            <h4 style="margin: 0 0 15px 0; color: #2d3748;">📧 Batch ${batchNumber} of ${totalBatches} - Ready to Open ${currentBatch.length} Emails:</h4>
                            ${currentBatch.map((email, index) => `
                                <div style="background: white; margin: 8px 0; padding: 12px; border-radius: 8px; border-left: 4px solid #4299e1;">
                                    <div style="font-weight: bold; font-size: 14px; color: #2d3748; margin-bottom: 5px;">${email.story}</div>
                                    <div style="color: #4a5568; margin-bottom: 5px; font-size: 13px; line-height: 1.3;">${email.storyTitle}</div>
                                    <div style="font-size: 12px; color: #666;">
                                        <strong>TO:</strong> ${email.assigneeName} | <strong>CC:</strong> ${email.reporterName}
                                    </div>
                                </div>
                            `).join('')}
                        </div>
                        
                        <div style="margin-bottom: 20px;">
                            <button onclick="openCurrentBatch()" style="
                                background: linear-gradient(135deg, #48bb78 0%, #38a169 100%); 
                                color: white; 
                                border: none; 
                                padding: 20px 50px; 
                                border-radius: 12px; 
                                cursor: pointer; 
                                font-size: 18px;
                                font-weight: bold;
                                margin-right: 15px;
                                box-shadow: 0 6px 20px rgba(72, 187, 120, 0.3);
                            " onmouseover="this.style.transform='translateY(-2px)'" onmouseout="this.style.transform='translateY(0)'">
                                � Auto-Open These ${currentBatch.length} Emails
                            </button>
                            
                            <button onclick="skipCurrentBatch()" style="
                                background: linear-gradient(135deg, #ed8936 0%, #dd6b20 100%); 
                                color: white; 
                                border: none; 
                                padding: 20px 30px; 
                                border-radius: 12px; 
                                cursor: pointer; 
                                font-size: 16px;
                                font-weight: bold;
                                box-shadow: 0 6px 20px rgba(237, 137, 54, 0.3);
                            " onmouseover="this.style.transform='translateY(-2px)'" onmouseout="this.style.transform='translateY(0)'">
                                ⏭️ Skip Batch
                            </button>
                        </div>
                        
                        <div style="background: #e6fffa; border: 1px solid #38b2ac; border-radius: 8px; padding: 15px; font-size: 14px; color: #234e52;">
                            <strong>💡 How it works:</strong> One click will automatically open all ${currentBatch.length} emails in this batch with small delays between each email to ensure reliable opening.
                        </div>
                    `;
                }
                
                function openCurrentBatch() {
                    const currentBatch = emailsData.slice(currentIndex, Math.min(currentIndex + BATCH_SIZE, totalEmails));
                    
                    // Show processing status
                    progressContent.innerHTML = `
                        <h3 style="color: #38b2ac; margin-bottom: 25px;">🔄 Opening Batch ${batchesProcessed + 1}...</h3>
                        <div style="background: #e6fffa; border: 2px solid #38b2ac; border-radius: 8px; padding: 20px; text-align: center;">
                            <div class="spinner" style="
                                width: 30px; 
                                height: 30px; 
                                border: 4px solid #b2f5ea; 
                                border-top: 4px solid #38b2ac; 
                                border-radius: 50%; 
                                animation: spin 1s linear infinite;
                                margin: 0 auto 15px;
                            "></div>
                            <div style="font-size: 16px; font-weight: bold; color: #234e52;">
                                Opening ${currentBatch.length} emails automatically...
                            </div>
                            <div style="font-size: 14px; color: #2d5016; margin-top: 10px;">
                                Please wait while we open each email with proper timing
                            </div>
                        </div>
                        <style>
                            @keyframes spin {
                                0% { transform: rotate(0deg); }
                                100% { transform: rotate(360deg); }
                            }
                        </style>
                    `;
                    
                    // Open all emails in this batch automatically with staggered timing
                    currentBatch.forEach((email, index) => {
                        setTimeout(() => {
                            try {
                                console.log(`🚀 Opening email ${currentIndex + index + 1}/${totalEmails}: ${email.story}`);
                                
                                // Use window.open for better reliability with user interaction
                                window.open(email.mailtoLink);
                                
                                successCount++;
                                console.log(`✅ Successfully opened email for ${email.story}`);
                            } catch (error) {
                                console.error(`❌ Failed to open email for ${email.story}:`, error);
                                failureCount++;
                                retryQueue.push(email);
                            }
                        }, index * 800); // 800ms delay between each email in batch
                    });
                    
                    // After opening all emails in batch, move to next batch
                    setTimeout(() => {
                        currentIndex += currentBatch.length;
                        batchesProcessed++;
                        processNextBatch();
                    }, currentBatch.length * 800 + 1000); // Wait for all emails plus extra buffer
                }
                
                function skipCurrentBatch() {
                    const currentBatch = emailsData.slice(currentIndex, Math.min(currentIndex + BATCH_SIZE, totalEmails));
                    failureCount += currentBatch.length;
                    retryQueue.push(...currentBatch);
                    currentIndex += currentBatch.length;
                    batchesProcessed++;
                    setTimeout(processNextBatch, 100);
                }
                
                function processNextEmail() {
                    // This function is now replaced by batch processing
                    processNextBatch();
                }
                
                function showCompletionStatus() {
                    const successRate = Math.round((successCount / totalEmails) * 100);
                    const hasRetries = retryQueue.length > 0;
                    
                    progressContent.innerHTML = `
                        <h3 style="color: ${successRate >= 90 ? '#48bb78' : '#f6ad55'}; margin-bottom: 25px;">
                            ${successRate >= 90 ? '✅' : '⚠️'} Email Processing Complete!
                        </h3>
                        
                        <div style="display: grid; grid-template-columns: repeat(auto-fit, minmax(200px, 1fr)); gap: 20px; margin-bottom: 25px;">
                            <div style="background: #e6fffa; padding: 20px; border-radius: 12px; border: 2px solid #38b2ac;">
                                <div style="font-size: 24px; font-weight: bold; color: #38b2ac;">${successCount}</div>
                                <div style="color: #4a5568;">Emails Opened</div>
                            </div>
                            <div style="background: ${failureCount > 0 ? '#fed7d7' : '#f0f9f0'}; padding: 20px; border-radius: 12px; border: 2px solid ${failureCount > 0 ? '#e53e3e' : '#48bb78'};">
                                <div style="font-size: 24px; font-weight: bold; color: ${failureCount > 0 ? '#e53e3e' : '#48bb78'};">${failureCount}</div>
                                <div style="color: #4a5568;">Failed/Skipped</div>
                            </div>
                            <div style="background: #e6f3ff; padding: 20px; border-radius: 12px; border: 2px solid #4299e1;">
                                <div style="font-size: 24px; font-weight: bold; color: #4299e1;">${successRate}%</div>
                                <div style="color: #4a5568;">Success Rate</div>
                            </div>
                        </div>
                        
                        <div style="background: #f8f9fa; padding: 20px; border-radius: 12px; margin-bottom: 20px; text-align: left;">
                            <h4 style="margin: 0 0 15px 0; color: #2d3748;">📊 Summary Report:</h4>
                            <div style="line-height: 1.6;">
                                • <strong>Total Emails:</strong> ${totalEmails}<br>
                                • <strong>Successfully Opened:</strong> ${successCount}<br>
                                • <strong>Failed/Skipped:</strong> ${failureCount}<br>
                                • <strong>Processing Method:</strong> Direct Outlook Automation (sent via Outlook, saved to Sent Items)<br>
                                ${hasRetries ? `• <strong>Available for Retry:</strong> ${retryQueue.length}` : ''}
                            </div>
                        </div>
                        
                        ${hasRetries ? `
                            <div style="margin-bottom: 20px;">
                                <button onclick="retryFailedEmails()" style="
                                    background: linear-gradient(135deg, #ed8936 0%, #dd6b20 100%); 
                                    color: white; 
                                    border: none; 
                                    padding: 15px 30px; 
                                    border-radius: 10px; 
                                    cursor: pointer; 
                                    font-size: 16px;
                                    font-weight: bold;
                                    margin-right: 15px;
                                ">🔄 Retry Failed Emails (${retryQueue.length})</button>
                            </div>
                        ` : ''}
                        
                        <div style="margin-bottom: 20px;">
                            <button onclick="closeEmailModal()" style="
                                background: #4299e1; 
                                color: white; 
                                border: none; 
                                padding: 15px 30px; 
                                border-radius: 10px; 
                                cursor: pointer; 
                                font-size: 16px;
                                font-weight: bold;
                            ">Close</button>
                        </div>
                        
                        <div style="background: ${successRate >= 90 ? '#d4edda' : '#fff3cd'}; border-radius: 8px; padding: 15px; font-size: 14px;">
                            ${successRate >= 90 ? 
                                '🎉 <strong>Excellent!</strong> All emails opened successfully via batch processing. Check your Outlook for email drafts.' :
                                '💡 <strong>Tip:</strong> Batch processing opens 3 emails per click. You can retry failed emails or use the consolidated email option.'
                            }
                        </div>
                    `;
                }
                
                function retryFailedEmails() {
                    if (retryQueue.length === 0) return;
                    
                    // Reset counters for retry
                    currentIndex = 0;
                    emailsData = [...retryQueue]; // Use retry queue as new email data
                    retryQueue = [];
                    successCount = 0;
                    failureCount = 0;
                    batchesProcessed = 0;
                    
                    // Restart batch process with failed emails
                    setTimeout(processNextBatch, 500);
                }
                
                function closeEmailModal() {
                    if (modal && modal.parentNode) {
                        modal.remove();
                    }
                    if (progressModal && progressModal.parentNode) {
                        progressModal.remove();
                    }
                    delete window.sendAllIndividualEmails;
                    delete window.openCurrentBatch;
                    delete window.skipCurrentBatch;
                    delete window.retryFailedEmails;
                    delete window.closeEmailModal;
                }
                
                // Make functions globally accessible
                window.openCurrentBatch = openCurrentBatch;
                window.skipCurrentBatch = skipCurrentBatch;
                window.retryFailedEmails = retryFailedEmails;
                window.closeEmailModal = closeEmailModal;
                
                // Start the batch processing
                processNextBatch();
            };

            // Add consolidated email function as backup option
            window.sendConsolidatedEmail = function() {
                console.log(`📋 Creating consolidated email for all ${emailsData.length} stories...`);
                
                // Create the consolidated email content
                const allEmails = emailsData.map(email => email.to).filter((value, index, self) => self.indexOf(value) === index);
                const allCCs = emailsData.map(email => email.cc).filter((value, index, self) => self.indexOf(value) === index);
                
                const toList = allEmails.join(';');
                const ccList = allCCs.join(';');
                
                const subject = `Multiple JIRA Stories Missing Information - ${epicKey}`;
                
                const emailBody = `Dear Team,

Please find below the list of ${emailsData.length} JIRA stories that are missing required information and need your attention:

${emailsData.map((email, index) => 
`${index + 1}. Story: ${email.story}
   Title: ${email.storyTitle}
   Reporter: ${email.reporterName} (${email.to})
   Assignee: ${email.assigneeName} (${email.cc})
   
   Missing Information:
   ${email.missingFields.join(', ')}
   
   Please update this story with the missing information.
   
`).join('')}

Please ensure all missing information is provided to keep our project on track.

Best regards,
Feature Lifecycle Navigator Team

---
This email was generated automatically by the Feature Lifecycle Navigator system.
Epic: ${epicKey}
Generated: ${new Date().toLocaleString()}`;

                const encodedSubject = encodeURIComponent(subject);
                const encodedBody = encodeURIComponent(emailBody);
                const mailtoLink = `mailto:${toList}?cc=${ccList}&subject=${encodedSubject}&body=${encodedBody}`;
                
                // Try to open the consolidated email
                try {
                    window.open(mailtoLink);
                    
                    alert(`📋 Consolidated email created!\n\n✅ TO: ${allEmails.length} unique recipients\n✅ CC: ${allCCs.length} unique assignees\n✅ Stories: ${emailsData.length} total\n\nOne email window should open with all the information.`);
                    
                } catch (error) {
                    console.error('Error opening consolidated email:', error);
                    
                    // Fallback: show the mailto link
                    const fallbackModal = document.createElement('div');
                    fallbackModal.style.cssText = `
                        position: fixed; top: 0; left: 0; width: 100%; height: 100%;
                        background: rgba(0,0,0,0.8); z-index: 10002; display: flex;
                        align-items: center; justify-content: center;
                    `;
                    
                    fallbackModal.innerHTML = `
                        <div style="background: white; padding: 30px; border-radius: 12px; max-width: 600px; width: 90%;">
                            <h3 style="color: #e53e3e; margin-bottom: 20px;">⚠️ Email Client Issue</h3>
                            <p style="margin-bottom: 20px;">Could not automatically open your email client. Please copy the link below and paste it in your browser:</p>
                            <textarea readonly style="width: 100%; height: 100px; margin-bottom: 20px; padding: 10px; border: 1px solid #ccc; border-radius: 4px; font-family: monospace; font-size: 12px;">${mailtoLink}</textarea>
                            <button onclick="this.parentElement.parentElement.remove()" style="background: #4299e1; color: white; border: none; padding: 10px 20px; border-radius: 4px; cursor: pointer;">Close</button>
                        </div>
                    `;
                    
                    document.body.appendChild(fallbackModal);
                }
                
                // Close the original modal
                modal.remove();
                delete window.sendConsolidatedEmail;
            };

            // Add aggressive force function to bypass popup blockers
            window.forceOpenAllEmails = function() {
                console.log(`🚀 FORCE: Opening all ${emailsData.length} emails with aggressive bypass...`);
                
                alert(`🚀 FORCE MODE: Opening ${emailsData.length} emails NOW!\n\nThis will:\n1. Try multiple window.open methods\n2. Create temporary links\n3. Use focus tricks to bypass blockers\n\nPlease allow popups when prompted!`);
                
                emailsData.forEach((email, index) => {
                    // Use multiple strategies immediately
                    setTimeout(() => {
                        console.log(`FORCE: Opening email ${index + 1} for ${email.story}`);
                        
                        // Strategy 1: Standard window.open with unique name
                        const win1 = window.open(email.mailtoLink, `email_${email.story}_${Date.now()}_${index}`);
                        
                        // Strategy 2: Create and auto-click invisible link
                        const tempLink = document.createElement('a');
                        tempLink.href = email.mailtoLink;
                        tempLink.target = '_blank';
                        tempLink.style.display = 'none';
                        tempLink.id = `templink_${index}`;
                        document.body.appendChild(tempLink);
                        
                        // Auto-click after tiny delay
                        setTimeout(() => {
                            tempLink.click();
                            setTimeout(() => {
                                if (document.getElementById(`templink_${index}`)) {
                                    document.body.removeChild(tempLink);
                                }
                            }, 100);
                        }, 10);
                        
                        // Strategy 3: Try to focus and reopen if blocked
                        if (!win1 || win1.closed) {
                            setTimeout(() => {
                                try {
                                    window.open(email.mailtoLink, '_blank');
                                } catch (e) {
                                    console.log(`Fallback failed for ${email.story}:`, e);
                                }
                            }, 20);
                        }
                        
                    }, index * 25); // Even shorter delays - 25ms
                });
                
                setTimeout(() => {
                    alert(`🎯 FORCE COMPLETE!\n\nAttempted to force-open all ${emailsData.length} emails using multiple bypass strategies.\n\n✅ Check your email client now!\n\nIf some emails didn't open, your browser has very strict popup blocking.`);
                    modal.remove();
                    delete window.forceOpenAllEmails;
                    delete window.sendAllIndividualEmails;
                }, (emailsData.length * 25) + 500);
            };

        } // Close showIndividualEmailModal

        function getStoriesForEmailEpic(epicKey) {
            console.log('Getting stories for epic:', epicKey);
            console.log('Available epic-story relationships:', Object.keys(window.currentEpicsWithStories || {}));
            
            let stories = window.currentEpicsWithStories?.[epicKey] || [];
            console.log('Stories found in cache:', stories.length);
            
            if (stories.length === 0) {
                console.log('No stories found in cached data, trying DOM parsing...');
                
                // Alternative: Parse stories from the currently displayed DOM
                const epicCard = document.querySelector(`[data-epic-key="${epicKey}"]`);
                if (!epicCard) {
                    // Try to find the epic card by looking for the epic key in the text
                    const allFeatureCards = document.querySelectorAll('.feature-card');
                    for (const card of allFeatureCards) {
                        if (card.innerHTML.includes(epicKey)) {
                            console.log('Found epic card in DOM');
                            // Extract story information from the DOM
                            const storyElements = card.querySelectorAll('[data-story-key]');
                            console.log('Story elements found in DOM:', storyElements.length);
                            break;
                        }
                    }
                }
                
                // Fallback: try to get from current search data
                const allData = window.currentSearchData || [];
                console.log('Fallback: Total search data available:', allData.length);
                
                const fallbackStories = allData.filter(item => {
                    // Check multiple ways a story can be linked to an epic
                    const epicLink = item.fields.customfield_10014; // Epic Link field
                    const parent = item.fields.parent?.key;
                    const issueType = item.fields.issuetype?.name;
                    
                    const isLinkedToEpic = epicLink === epicKey || parent === epicKey;
                    const isStory = issueType === 'Story';
                    
                    console.log(`Item ${item.key}: type=${issueType}, epicLink=${epicLink}, parent=${parent}, linked=${isLinkedToEpic}`);
                    
                    return isLinkedToEpic && isStory;
                });
                
                console.log('Fallback stories found:', fallbackStories.length, fallbackStories.map(s => s.key));
                stories = fallbackStories;
            }
            
            return stories;
        }

        function findStoriesWithMissingFields(stories) {
            console.log('\n=== FILTERING STORIES FOR MISSING FIELDS ===');
            console.log('Input stories count:', stories.length);
            
            const filteredStories = stories.filter(story => {
                const descriptionEmpty = isFieldEmpty(story.fields.description, 'description');
                const criteriaEmpty = isFieldEmpty(story.fields.customfield_10056, 'customfield_10056');
                const hasMissingFields = descriptionEmpty || criteriaEmpty;
                
                console.log(`Story ${story.key}: desc=${descriptionEmpty}, criteria=${criteriaEmpty}, missing=${hasMissingFields}`);
                
                return hasMissingFields;
            });
            
            console.log('Filtered stories count:', filteredStories.length);
            console.log('Filtered stories keys:', filteredStories.map(s => s.key));
            console.log('=== FILTERING COMPLETE ===\n');
            
            return filteredStories;
        }

        function prepareEmailData(stories) {
            const emailGroups = {};
            
            console.log('\n=== PREPARING EMAIL DATA ===');
            console.log('Input stories for email preparation:', stories.length);
            
            stories.forEach(story => {
                console.log(`\n--- Story ${story.key} Email Data ---`);
                console.log('Full story reporter object:', story.fields.reporter);
                console.log('Reporter email path 1:', story.fields.reporter?.emailAddress);
                console.log('Reporter email path 2:', story.fields.reporter?.email);
                console.log('Full story assignee object:', story.fields.assignee);
                console.log('Assignee email path 1:', story.fields.assignee?.emailAddress);
                console.log('Assignee email path 2:', story.fields.assignee?.email);
                
                // Try multiple possible paths for reporter email
                let reporterEmail = null;
                let reporterName = 'Reporter';
                
                if (story.fields.reporter) {
                    reporterEmail = story.fields.reporter.emailAddress || 
                                  story.fields.reporter.email || 
                                  story.fields.reporter.name;
                    reporterName = story.fields.reporter.displayName || 
                                  story.fields.reporter.name || 
                                  'Reporter';
                }
                
                console.log('Resolved reporter email:', reporterEmail);
                console.log('Resolved reporter name:', reporterName);
                
                if (!reporterEmail) {
                    console.log(`⚠️ Skipping story ${story.key} - no reporter email found`);
                    return;
                }

                if (!emailGroups[reporterEmail]) {
                    emailGroups[reporterEmail] = {
                        reporterName: reporterName,
                        stories: [],
                        ccEmails: new Set()
                    };
                }

                const descriptionEmpty = isFieldEmpty(story.fields.description, 'description');
                const criteriaEmpty = isFieldEmpty(story.fields.customfield_10056, 'customfield_10056');
                
                // Try multiple possible paths for assignee email
                let assigneeEmail = null;
                let assigneeName = 'Unassigned';
                
                if (story.fields.assignee) {
                    assigneeEmail = story.fields.assignee.emailAddress || 
                                   story.fields.assignee.email || 
                                   story.fields.assignee.name;
                    assigneeName = story.fields.assignee.displayName || 
                                  story.fields.assignee.name || 
                                  'Assigned User';
                }
                
                console.log('Resolved assignee email:', assigneeEmail);
                console.log('Resolved assignee name:', assigneeName);
                
                // Add assignee email to CC if exists and different from reporter
                if (assigneeEmail && assigneeEmail !== reporterEmail) {
                    emailGroups[reporterEmail].ccEmails.add(assigneeEmail);
                }
                
                emailGroups[reporterEmail].stories.push({
                    key: story.key,
                    summary: story.fields.summary,
                    missingDescription: descriptionEmpty,
                    missingCriteria: criteriaEmpty,
                    assigneeName: assigneeName
                });
                
                console.log(`✅ Added story ${story.key} to email group for ${reporterEmail}`);
            });

            const result = Object.entries(emailGroups).map(([email, data]) => ({
                email,
                reporterName: data.reporterName,
                stories: data.stories,
                ccEmails: Array.from(data.ccEmails)
            }));
            
            console.log('\n=== EMAIL PREPARATION COMPLETE ===');
            console.log('Email groups created:', result.length);
            result.forEach((group, index) => {
                console.log(`Group ${index + 1}: ${group.email} (${group.stories.length} stories, CC: ${group.ccEmails.join(', ') || 'none'})`);
            });
            
            return result;
        }

        function generateEmailTemplate(reporterName, stories, ccEmails, featureInfo) {
            const storyList = stories.map(story => {
                const issues = [];
                if (story.missingDescription) issues.push('Missing Description');
                if (story.missingCriteria) issues.push('Missing High Level Acceptance Criteria');
                
                return `• ${story.key}: ${story.summary}
                  Issues: ${issues.join(', ')}
                  Assignee: ${story.assigneeName}`;
            }).join('\n\n');

            const featureText = featureInfo ? `for Feature ${featureInfo}` : '';
            
            return {
                subject: 'Action Required: Missing Information in Your JIRA Stories',
                body: `Dear ${reporterName},

As part of a recent review, we identified missing required information in the following JIRA stories ${featureText}:

${storyList}

Requested actions:
- Provide clear and complete descriptions where missing
- Add high-level acceptance criteria for each story
- Coordinate with the assignee(s) as needed

Please update the above items at your earliest convenience, or share an estimated timeline if additional input is required.

Thank you for your prompt attention.

Regards,
Zuha Mujawar`
            };
        }

        function generateIndividualStoryEmailTemplate(primaryRecipientName, story, ccRecipientName, featureInfo) {
            const issues = [];
            const descriptionEmpty = isFieldEmpty(story.fields.description, 'description');
            const criteriaEmpty = isFieldEmpty(story.fields.customfield_10056, 'customfield_10056');

            if (descriptionEmpty) issues.push('Missing Description');
            if (criteriaEmpty) issues.push('Missing High-Level Acceptance Criteria');

            const featureText = featureInfo ? ` for Feature ${featureInfo}` : '';
            const jiraBaseUrl = 'https://lumen.atlassian.net';
            const storyLink = `${jiraBaseUrl}/browse/${story.key}`;

            return {
                subject: `Action Required: Missing Information in JIRA Story ${story.key}${featureText}`,
                body: `Dear ${primaryRecipientName},

I hope you are well. During a recent review, we identified missing required information in the following JIRA story${featureText}:

Story: ${story.key} — ${story.fields.summary}
Missing items: ${issues.join(', ')}

Requested actions:
${descriptionEmpty ? '- Provide a clear and complete description.\n' : ''}${criteriaEmpty ? '- Add high-level acceptance criteria that define done.\n' : ''}

You can access the story here: ${storyLink}

Please update the story at your earliest convenience, or share an estimated timeline if additional input is required. If you have any questions, feel free to reply and I will be happy to assist.

Thank you for your prompt attention.

Regards,
Zuha Mujawar`
            };
        }

        // Initialize with empty state and load fix versions
        document.addEventListener('DOMContentLoaded', function() {
            console.log('DOM fully loaded');
            console.log('JQL Input element:', document.getElementById('jqlInput'));
            console.log('Suggestions dropdown element:', document.getElementById('suggestionsDropdown'));
            showEmptyState();
            loadFixVersions();
        });
        
        // Fallback for if DOMContentLoaded already fired
        if (document.readyState === 'loading') {
            // DOMContentLoaded will handle it
        } else {
            // DOM is already ready
            console.log('DOM already ready');
            console.log('JQL Input element:', document.getElementById('jqlInput'));
            console.log('Suggestions dropdown element:', document.getElementById('suggestionsDropdown'));
            showEmptyState();
            loadFixVersions();
        }
        
        // Add event delegation for story expand buttons
        document.addEventListener('click', function(event) {
            if (event.target.closest('.story-expand-btn')) {
                const button = event.target.closest('.story-expand-btn');
                const storyKey = button.getAttribute('data-story-key');
                console.log('Button clicked for story:', storyKey);
                if (storyKey) {
                    toggleStoryDetails(storyKey);
                }
            }
        });
    </script>
</body>
</html>
